<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>API Documentation - eYRC-VB#0302</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "API Documentation";
    var mkdocs_page_input_path = "api_documentation.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> eYRC-VB#0302</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../implementation/index.html">Implementation</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./index.html">API Documentation</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#pkg_task5">pkg_task5</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1node_t5py">1.node_t5.py</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2node_t5_ur5_2py">2.node_t5_ur5_2.py</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pkg_ros_iot_bridge">pkg_ros_iot_bridge</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-iotpy">1) iot.py</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2node_action_server_ros_iot_bridgepy">2)node_action_server_ros_iot_bridge.py</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3config_pyiotyaml">3)config_pyiot.yaml</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..index.html">eYRC-VB#0302</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
      
    
    <li>API Documentation</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="api-documentation"><p style="font-size: 30px; background: DarkSlateGray; color: AliceBlue" align="center"><b></br>API DOCUMENTATION</br></br></b></p></h1>
<p></br></p>
<p align="center">
  <img width="460" height="300" src="../img/finaltree2.png">
</p>

<h2 id="pkg_task5"><h2 style="background: AntiqueWhite" align="left"><b>pkg_task5</b></h2></h2>
<h3 id="1node_t5py"><h3>1.node_t5.py</h3></h3>
<p style="background: AliceBlue"><b>Importing all the necessary standard libraries.</b></br>This block imports all necessary header files required in the node.</p>
<p></br></p>
<p><pre class="highlight"><code class="language-python">import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

import tf2_ros
import tf2_msgs.msg
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

import requests

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage
import cv2</code></pre>
</br></p>
<p style="background: AliceBlue">This class is responsible for using the node as an action client</p>

<p><pre class="highlight"><code class="language-python">class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Constructor function of class IotRosBridgeActionClient.</b></br>-This block saves all the values from parameter server onto variables to be used later.</p>

<pre class="highlight"><code class="language-python">    # Constructor
    def __init__(self):
        '''Constructor function of class IotRosBridgeActionClient'''

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use the action
        # - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")</code></pre>
<p></br></p>
<p style="background: AliceBlue">This function will be called when there is a change of state in the Action Client State Machine</p>

<pre class="highlight"><code class="language-python">    def on_transition(self, goal_handle):
        '''This function will be called when there is a change of state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle
        # generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -&gt; Active
        # Comm State = 3 -&gt; Wating for Result
        # Comm State = 7 -&gt; Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success is True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>This function is used to send Goals to Action Server.</b></br>-As and when the action client function is called it send the recieved goal to the action server, this function has 4 arguments, containing information which is to be sent via the message file.</p>

<pre class="highlight"><code class="language-python">    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function
        # which will be called when there is a change of state
        # in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)</code></pre>
<p></br></p>
<p style="background: AliceBlue">This class performs image processing tasks</p>

<pre class="highlight"><code class="language-python">class Camera1:
    '''This class performs image processing tasks'''</code></pre>
<p></br></p>
<p style="background: AliceBlue">Constructor of class Camera1.</br>-Initializes and subscribes to the 2D Camera topic.</p>

<pre class="highlight"><code class="language-python">    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}
        print "Camera1 initialized"</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Decodes the QR code.</b></br>This function gets the entire image as a set of data, this is passed to the decode() function, which returns a dictionary containing information regarding the positions and decoded color of the respective package.</p>

<pre class="highlight"><code class="language-python">    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        len_lst = len(qr_result)
        color_dict = {}

        print("LENGTH OF qr_result", len_lst)

        for i in range(len_lst):
            if ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen00"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen01"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen02"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen10"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen11"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen12"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen20"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen21"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen22"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen30"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen31"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen32"] = qr_result[i].data

        return color_dict</code></pre>
<p></br></p>
<p style="background: AliceBlue">Unsubscriber function used to unsubscribe from topics</p>

<pre class="highlight"><code class="language-python">    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Callback function called everytime 2D Camera sends data.</b></br>The image id obtained as a stream of data, to this two image processing functions under cv packages is applied this will vary the light densities and denoise the stream of image. The parameters passed in the denoising function determine quality of the denoised image.</br>This denoised image is sent as an argument to get_qr_data() which then performs detection.</p>

<pre class="highlight"><code class="language-python">    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        print "CALLBACK ENTERED"
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None,
                                              20, 25, 7, 21)

        image = dst

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image = cv2.resize(image, (720/2, 1280/2))

        # cv2.imshow("/eyrc/vb/camera_1/image_raw", resized_image)

        self.dictorder = self.get_qr_data(image)

        print("PACKAGE ORDER", self.dictorder)

        cv2.waitKey(1)</code></pre>
<p></br></p>
<p style="background: AliceBlue">Main class that initializes the robot arms, configures MoveIt and contains object of action client class</p>

<pre class="highlight"><code class="language-python">class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Constructor of class Ur5Moveit</b></br>The created constructor provides access to the attributes and methods of the class Ur5Moveit. This consists of ‘ arg_robot_name’ as an argument,which is later initialised from the ‘main()’ function as 
ur5 = Ur5Moveit(sys.argv[1])</br>The constructor also enables the subscription to a local topic.Multiple empty lists have been created which are later used for sorting/segregation purposes.</p>

<pre class="highlight"><code class="language-python">    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._group.set_planning_time(99)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        self.placed_order = []
        self.placed_order_red =[]
        self.placed_order_yellow =[]
        self.placed_order_green =[]

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))

        rospy.loginfo('\033[94m' + " &gt;&gt;&gt; Ur5Moveit init done." +
                      '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.sub_callback)</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Callback function called everytime mqtt topic receives new orders</b></br>This function consists of ‘msg’ as an argument to it. When , rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub, self.sub_callback)  receives an order, ‘msgMqttSub’ is given as the argument for the sub_callback function. It contains 4 parameters, of which we need to access the ‘message’ parameter. A dictionary of the contents is created and items are appended to different lists based on their type to the respective colours.</p>

<pre class="highlight"><code class="language-python">    def sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print("PRINTING PAYLOAD FROM NEW NODE_T5", dict_payload)
        self.placed_order.append(dict_payload)

        if dict_payload['item'] == 'Medicine':
            self.placed_order_red.append(dict_payload)
        elif dict_payload['item'] == 'Food':
            self.placed_order_yellow.append(dict_payload)
        elif dict_payload['item'] == 'Clothes':
            self.placed_order_green.append(dict_payload)</code></pre>
<p></br></p>
<p style="background: AliceBlue">Clears the octomap</p>

<pre class="highlight"><code class="language-python">    def clear_octomap(self):
        '''Clears the octomap'''
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + "/clear_octomap", Empty)
        return clear_octomap_service_proxy()</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Function to set joint angles of arm with choice number of attempts</b></br>This Function is used to set joint angles of arm with number of attempts. Here,a list of home positions is passed as arguments from the main function along with the number of attempts.</p>

<pre class="highlight"><code class="language-python">    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Function to set Joint angles of the arm</b></br>It is a function to set joint angles of the arm. This is called in the 
def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
 function,and gives us the status of success/failed outcomes.</p>

<pre class="highlight"><code class="language-python">    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        # list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Current Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        # pose_values = self._group.get_current_pose().pose
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Pose:" + '\033[0m')
        # rospy.loginfo(pose_values)

        if flag_plan is True:
            pass
            # rospy.loginfo(# '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Success" +'\033[0m')
        else:
            pass
            # rospy.logerr(# '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Failed." + '\033[0m')

        return flag_plan</code></pre>
<p></br></p>
<p style="background: AliceBlue">Plays pre recorded path</p>

<pre class="highlight"><code class="language-python">    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret</code></pre>
<p></br></p>
<p style="background: AliceBlue">Plays pre recorded paths with choice number of attempts</p>

<pre class="highlight"><code class="language-python">    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''
        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Attaches/Detaches packages to vacuum gripper</b></br>This function is used to attach or detach package to vacuumGripper.A try and except block is used to produce the result (grip1.result). If an error is obtained the code goes to the except block and displays “Service call failed for attach".</p>

<pre class="highlight"><code class="language-python">    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach"</code></pre>
<p></br></p>
<p style="background: AliceBlue">Deletes object of class</p>

<pre class="highlight"><code class="language-python">    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments</b></br>This function recieves two arguments package name and the current order. Based on the package name, the ur5_1 arm picks the corresponding package from the shelf and will place it on the conveyor belt. Subsequently a goal is sent to the action server that the package is dispatched.</p>

<pre class="highlight"><code class="language-python">    def func_packages(self, pkg_name, new_dict):
        '''Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments'''

        if pkg_name == "packagen00":
            #  Picking Package 00 from the shelf
            all_zero_list = [math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00)]

            self.hard_set_joint_angles(all_zero_list, 5)

            rospy.logwarn("1. Playing AllZeros to Pose#1 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'zero_to_pkg1.yaml',
                                                         5)
            rospy.sleep(2)
            attach = self.attach_or_detach_to_vg(True)
            if attach:
                rospy.logwarn("2.Playing Packagen00 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen00_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle0 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle0
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen01":
            #  Picking Package 01 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_2 = 0
            rospy.logwarn("1. Playing Home to Pkg2 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg2.yaml',
                                                         5)
            attached_2 = self.attach_or_detach_to_vg(True)
            if attached_2:
                rospy.logwarn("2.Playing Packagen01 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen01_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle1 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle1
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen02":
            #  Picking Package 02 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attched_3 = 0
            rospy.logwarn("1. Playing Home to Pkg3 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg3.yaml',
                                                         5)
            attached_3 = self.attach_or_detach_to_vg(True)
            if attached_3:
                rospy.logwarn("1. Playing Pkg3 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen02_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle2 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle2
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen10":
            #  Picking Package 10 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_4 = 0
            rospy.logwarn("1. Playing Home to Pkg4 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg4.yaml',
                                                         5)
            attached_4 = self.attach_or_detach_to_vg(True)
            if attached_4:
                rospy.logwarn("1. Playing Pkg4 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen10_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle3 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle3
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen11":
            #  Picking Package 11 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_5 = 0
            rospy.logwarn("1. Playing Home to Pkg5 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg5.yaml',
                                                         5)
            attached_5 = self.attach_or_detach_to_vg(True)
            if attached_5:
                rospy.logwarn("1. Playing Pkg5 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen11_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle4 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle4
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen12":
            #  Picking Package 12 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_6 = 0
            rospy.logwarn("1. Playing Home to Pkg6 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg6.yaml',
                                                         5)
            attached_6 = self.attach_or_detach_to_vg(True)
            if attached_6:
                rospy.logwarn("1. Playing Pkg6 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen12_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle5 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle5
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen30":
            #  Picking Package 30 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg10 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg10.yaml', 5)
            attached_10 = 0
            attached_10 = self.attach_or_detach_to_vg(True)
            if attached_10:
                rospy.logwarn("1. Playing Pkg10 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg10 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle6 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                self.action_client._goal_handles[self.i] = goal_handle6                                        # updating goal handle
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen31":
            #  Picking Package 31 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg11 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg11.yaml',
                                                         5)
            attached_11 = 0
            attached_11 = self.attach_or_detach_to_vg(True)
            if attached_11:
                rospy.logwarn("1. Playing Pkg11 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg11 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle7 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle7
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen32":
            #  Picking Package 32 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_12 = 0
            rospy.logwarn("1. Playing Home to Pkg12 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg12.yaml',
                                                         5)
            attached_12 = self.attach_or_detach_to_vg(True)
            if attached_12:
                rospy.logwarn("1. Playing Pkg32  to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_to_cartesian.yaml', 5)
                rospy.logwarn("1. Playing  cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_cartesian_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle8 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle8
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Main function declaration</b></br>A buffer time of 20 seconds is provided for the packages to spawn. Initially all the detected packages on the shelf are grouped to three lists based on their colour. These lists are sorted in increasing order of their position in shelf. This is done in order to move from one end of the shelf. As when the orders are received, the order dictionaries are appended to a list in the callback function. Then the while loop checks for red first indicating high priority, then yellow and lastly for green package. Now suppose red package doesn't arrive, it'll continue with the next highest priority order.</p>

<pre class="highlight"><code class="language-python">def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ic = Camera1()

    lst_red = []
    lst_green = []
    lst_yellow = []

    rospy.sleep(5)

    # Sort the detected packages into respective lists based on color
    dict_order_temp = ic.dictorder
    print "PRINTING DICTORDER", dict_order_temp
    for i in dict_order_temp.items():
        if i[1] == "red":
            lst_red.append(i)
            print("PRINTING SEPERATELY", lst_red)
        elif i[1] == "yellow":
            lst_yellow.append(i)
        elif i[1] == "green":
            lst_green.append(i)

    lst_red.sort(key=lambda x: x[0])
    lst_yellow.sort(key=lambda x: x[0])
    lst_green.sort(key=lambda x: x[0])
    print "PRINTING LISTS", lst_red, lst_yellow, lst_green
    lst_red.pop(2)
    lst_yellow.pop(2)
    lst_green.pop(2)
    print "POPPED LISTS", lst_red, lst_yellow, lst_green

    ic.unsubscribe()

    # Define position above conveyor belt
    home_pos_list = [math.radians(7.838),
                     math.radians(-139.943),
                     math.radians(-58.278),
                     math.radians(-71.819),
                     math.radians(89.975),
                     math.radians(7.833)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    # Used for traversing the list of dictionaries
    i = 0

    while not rospy.is_shutdown():

        if ur5.placed_order != []:

            while i &lt; len(ur5.placed_order):
                if ur5.placed_order_red !=[]:
                    print "ENTERED RED IN MAIN"
                    var_flag = lst_red[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_red[0])
                    ur5.placed_order_red.pop(0)
                    lst_red.pop(0)
                    i += 1

                elif ur5.placed_order_yellow !=[]:
                    var_flag = lst_yellow[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_yellow[0])
                    ur5.placed_order_yellow.pop(0)
                    lst_yellow.pop(0)
                    i += 1

                elif ur5.placed_order_green !=[]:
                    var_flag = lst_green[0][0]
                    print "DETECTED GREEN"
                    ur5.func_packages(var_flag, ur5.placed_order_green[0])
                    ur5.placed_order_green.pop(0)
                    lst_green.pop(0)
                    i += 1
    del ur5</code></pre>
<p></br></p>
<p style="background: AliceBlue">Calling main function</p>

<pre class="highlight"><code class="language-python">if __name__ == '__main__':
    main()
</code></pre>
<p></br></p>
<p style="font-size: 20px"><b>Complete code of node_t5.py</b></p>

<pre class="highlight"><code class="language-python">#! /usr/bin/env python

import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

import tf2_ros
import tf2_msgs.msg
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

import requests

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage

import cv2


class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''

    # Constructor
    def __init__(self):
        '''Constructor function of class IotRosBridgeActionClient'''

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use the action
        # - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    def on_transition(self, goal_handle):
        '''This function will be called when there is a change of state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle
        # generated by send_goal() is used here.

        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -&gt; Active
        # Comm State = 3 -&gt; Wating for Result
        # Comm State = 7 -&gt; Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success is True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function
        # which will be called when there is a change of state
        # in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle


class Camera1:
    '''This class performs image processing tasks'''

    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}
        print "Camera1 initialized"

    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        len_lst = len(qr_result)
        color_dict = {}

        print("LENGTH OF qr_result", len_lst)

        for i in range(len_lst):
            if ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen00"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen01"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340)):
                color_dict["packagen02"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen10"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen11"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520)):
                color_dict["packagen12"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen20"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen21"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660)):
                color_dict["packagen22"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen30"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen31"] = qr_result[i].data
            elif ((qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810)):
                color_dict["packagen32"] = qr_result[i].data

        return color_dict

    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()

    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        print "CALLBACK ENTERED"
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None,
                                              20, 25, 7, 21)

        image = dst

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image = cv2.resize(image, (720/2, 1280/2))

        # cv2.imshow("/eyrc/vb/camera_1/image_raw", resized_image)

        self.dictorder = self.get_qr_data(image)

        print("PACKAGE ORDER", self.dictorder)

        cv2.waitKey(1)


class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''

    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._group.set_planning_time(99)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        self.placed_order = []
        self.placed_order_red =[]
        self.placed_order_yellow =[]
        self.placed_order_green =[]

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))

        rospy.loginfo('\033[94m' + " &gt;&gt;&gt; Ur5Moveit init done." +
                      '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.sub_callback)

    def sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print("PRINTING PAYLOAD FROM NEW NODE_T5", dict_payload)
        self.placed_order.append(dict_payload)

        if dict_payload['item'] == 'Medicine':
            self.placed_order_red.append(dict_payload)
        elif dict_payload['item'] == 'Food':
            self.placed_order_yellow.append(dict_payload)
        elif dict_payload['item'] == 'Clothes':
            self.placed_order_green.append(dict_payload)        

    def clear_octomap(self):
        '''Clears the octomap'''
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + "/clear_octomap", Empty)
        return clear_octomap_service_proxy()

    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))

    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        # list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Current Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Joint Values:" + '\033[0m')
        # rospy.loginfo(list_joint_values)

        # pose_values = self._group.get_current_pose().pose
        # rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Pose:" + '\033[0m')
        # rospy.loginfo(pose_values)

        if flag_plan is True:
            pass
            # rospy.loginfo(# '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Success" +'\033[0m')
        else:
            pass
            # rospy.logerr(# '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Failed." + '\033[0m')

        return flag_plan

    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret

    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''
        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True


    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach"


    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')

    def func_packages(self, pkg_name, new_dict):
        '''Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments'''

        if pkg_name == "packagen00":
            #  Picking Package 00 from the shelf
            all_zero_list = [math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00),
                             math.radians(0.00)]

            self.hard_set_joint_angles(all_zero_list, 5)

            rospy.logwarn("1. Playing AllZeros to Pose#1 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'zero_to_pkg1.yaml',
                                                         5)
            rospy.sleep(2)
            attach = self.attach_or_detach_to_vg(True)
            if attach:
                rospy.logwarn("2.Playing Packagen00 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen00_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle0 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle0
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen01":
            #  Picking Package 01 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_2 = 0
            rospy.logwarn("1. Playing Home to Pkg2 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg2.yaml',
                                                         5)
            attached_2 = self.attach_or_detach_to_vg(True)
            if attached_2:
                rospy.logwarn("2.Playing Packagen01 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen01_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle1 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle1
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen02":
            #  Picking Package 02 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attched_3 = 0
            rospy.logwarn("1. Playing Home to Pkg3 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg3.yaml',
                                                         5)
            attached_3 = self.attach_or_detach_to_vg(True)
            if attached_3:
                rospy.logwarn("1. Playing Pkg3 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen02_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle2 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle2
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen10":
            #  Picking Package 10 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_4 = 0
            rospy.logwarn("1. Playing Home to Pkg4 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg4.yaml',
                                                         5)
            attached_4 = self.attach_or_detach_to_vg(True)
            if attached_4:
                rospy.logwarn("1. Playing Pkg4 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen10_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle3 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle3
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen11":
            #  Picking Package 11 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_5 = 0
            rospy.logwarn("1. Playing Home to Pkg5 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg5.yaml',
                                                         5)
            attached_5 = self.attach_or_detach_to_vg(True)
            if attached_5:
                rospy.logwarn("1. Playing Pkg5 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen11_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle4 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle4
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen12":
            #  Picking Package 12 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_6 = 0
            rospy.logwarn("1. Playing Home to Pkg6 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg6.yaml',
                                                         5)
            attached_6 = self.attach_or_detach_to_vg(True)
            if attached_6:
                rospy.logwarn("1. Playing Pkg6 to Home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen12_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle5 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle5
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen30":
            #  Picking Package 30 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg10 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg10.yaml', 5)
            attached_10 = 0
            attached_10 = self.attach_or_detach_to_vg(True)
            if attached_10:
                rospy.logwarn("1. Playing Pkg10 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg10 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle6 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                self.action_client._goal_handles[self.i] = goal_handle6                                        # updating goal handle
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen31":
            #  Picking Package 31 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            rospy.logwarn("1. Playing Home to Pkg11 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg11.yaml',
                                                         5)
            attached_11 = 0
            attached_11 = self.attach_or_detach_to_vg(True)
            if attached_11:
                rospy.logwarn("1. Playing Pkg11 to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_to_cartesian_ALTERNATE.yaml', 5)
                rospy.logwarn("1. Playing Pkg11 cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_cartesian_to_home_ALTERNATE.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle7 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle7
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")

        if pkg_name == "packagen32":
            #  Picking Package 32 from the shelf

            # self.hard_set_joint_angles(home_pos_list, 5)
            attached_12 = 0
            rospy.logwarn("1. Playing Home to Pkg12 Trajectory File")
            self.moveit_hard_play_planned_path_from_file(self._file_path,
                                                         'home_to_pkg12.yaml',
                                                         5)
            attached_12 = self.attach_or_detach_to_vg(True)
            if attached_12:
                rospy.logwarn("1. Playing Pkg32  to cartesian Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_to_cartesian.yaml', 5)
                rospy.logwarn("1. Playing  cartesian to home Trajectory File")
                self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_cartesian_to_home.yaml', 5)
                self.attach_or_detach_to_vg(False)

                mesg = json.dumps(new_dict)
                goal_handle8 = self.action_client.send_goal("mqtt", "pub_dispatch", self.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                # updating goal handle
                self.action_client._goal_handles[self.i] = goal_handle8
                self.i += 1
                rospy.loginfo("Goal #" + str(self.i-1) + " Sent")


def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ic = Camera1()

    lst_red = []
    lst_green = []
    lst_yellow = []

    rospy.sleep(5)

    # Sort the detected packages into respective lists based on color
    dict_order_temp = ic.dictorder
    print "PRINTING DICTORDER", dict_order_temp
    for i in dict_order_temp.items():
        if i[1] == "red":
            lst_red.append(i)
            print("PRINTING SEPERATELY", lst_red)
        elif i[1] == "yellow":
            lst_yellow.append(i)
        elif i[1] == "green":
            lst_green.append(i)

    lst_red.sort(key=lambda x: x[0])
    lst_yellow.sort(key=lambda x: x[0])
    lst_green.sort(key=lambda x: x[0])
    print "PRINTING LISTS", lst_red, lst_yellow, lst_green
    lst_red.pop(2)
    lst_yellow.pop(2)
    lst_green.pop(2)
    print "POPPED LISTS", lst_red, lst_yellow, lst_green

    ic.unsubscribe()

    # Define position above conveyor belt
    home_pos_list = [math.radians(7.838),
                     math.radians(-139.943),
                     math.radians(-58.278),
                     math.radians(-71.819),
                     math.radians(89.975),
                     math.radians(7.833)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    # Used for traversing the list of dictionaries
    i = 0

    while not rospy.is_shutdown():

        if ur5.placed_order != []:

            while i &lt; len(ur5.placed_order):
                if ur5.placed_order_red !=[]:
                    print "ENTERED RED IN MAIN"
                    var_flag = lst_red[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_red[0])
                    ur5.placed_order_red.pop(0)
                    lst_red.pop(0)
                    i += 1

                elif ur5.placed_order_yellow !=[]:
                    var_flag = lst_yellow[0][0]
                    ur5.func_packages(var_flag, ur5.placed_order_yellow[0])
                    ur5.placed_order_yellow.pop(0)
                    lst_yellow.pop(0)
                    i += 1

                elif ur5.placed_order_green !=[]:
                    var_flag = lst_green[0][0]
                    print "DETECTED GREEN"
                    ur5.func_packages(var_flag, ur5.placed_order_green[0])
                    ur5.placed_order_green.pop(0)
                    lst_green.pop(0)
                    i += 1
    del ur5


if __name__ == '__main__':
    main()
</code></pre>
<h3 id="2node_t5_ur5_2py"><h3>2.node_t5_ur5_2.py</h3></h3>
<p style="background: AliceBlue"><b>Importing all the standard libraries</b></br>This block imports all necessary header files required in the node.</p>

<pre class="highlight"><code class="language-python">#! /usr/bin/env python

import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

import tf2_ros
import tf2_msgs.msg
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

import requests

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage

import cv2</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>This class is responsible for using the node as an action client</b></br>This block saves all the values from parameter server onto variables to be used later.</p>

<p><pre class="highlight"><code class="language-python">class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''</code></pre>
</br></p>
<p style="background: AliceBlue">Constructor function</p>

<p><pre class="highlight"><code class="language-python">    # Constructor
    def __init__(self):

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use
        # the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")</code></pre>
</br></p>
<p style="background: AliceBlue">This function will be called when there is a change of 
        state in the Action Client State Machine</p>

<p><pre class="highlight"><code class="language-python">def on_transition(self, goal_handle):
        '''This function will be called when there is a change of 
        state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle generated by
        # send_goal() is used here.
        result = msgRosIotResult()
        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " +
                      str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))
        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -&gt; Active
        # Comm State = 3 -&gt; Wating for Result
        # Comm State = 7 -&gt; Done
        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")
        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " +
                              str(index))</code></pre>
</br></p>
<p style="background: AliceBlue"><b>This function is used to send Goals to Action Server</b></br>-As and when the action client function is called it send the recieved goal to the action server, this function has 4 arguments, containing information which is to be sent via the message file.</p>
</p>
<p><pre class="highlight"><code class="language-python">    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")
        # self.on_transition - It is a function pointer to a
        # function which will be called when
        # there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle</code></pre>
</br></p>
<p style="background: AliceBlue">This class performs image processing tasks</p>

<p><pre class="highlight"><code class="language-python">class Camera1:
    '''This class performs image processing tasks'''</code></pre>
</br></p>
<p style="background: AliceBlue">Constructor of class Camera1</p>

<p><pre class="highlight"><code class="language-python">    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Decodes the qr code</b></br>This function gets the entire image as a set of data, this is passed to the decode() function, which returns a dictionary containing information regarding the positions and decoded color of the respective package.</p>
</p>
<pre class="highlight"><code class="language-python">    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        len_lst = len(qr_result)
        color_dict = {}

        print "LENGTH OF qr_result", len_lst

        for i in range(len_lst):
            if (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen00"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen01"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen02"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen10"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen11"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen12"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen20"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen21"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen22"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen30"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen31"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen32"] = qr_result[i].data

        # print("FINAL DICTIONAR LIST", color_dict)

        return color_dict</code></pre>
<p></br></p>
<p style="background: AliceBlue">Unsubscriber function used to unsubscribe from topics</p>

<pre class="highlight"><code class="language-python">    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()</code></pre>
<p></br></p>
<p style="background: AliceBlue"><b>Callback function called everytime 2D Camera sends data</b></br>The image id obtained as a stream of data, to this two image processing functions under cv packages is applied this will vary the light densities and denoise the stream of image. The parameters passed in the denoising function determine quality of the denoised image.</br>This denoised image is sent as an argument to get_qr_data() which then performs detection.</p>

<p><pre class="highlight"><code class="language-python">    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        print "CALLBACK ENTERED"
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None,
                                              20, 25, 7, 21)

        image = dst

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image = cv2.resize(image, (720/2, 1280/2))

        # cv2.imshow("/eyrc/vb/camera_1/image_raw", resized_image)

        self.dictorder = self.get_qr_data(image)

        print("PACKAGE ORDER", self.dictorder)

        cv2.waitKey(1)</code></pre>
</br></p>
<p style="background: AliceBlue">Main class that initializes the robot arms, configures MoveIt and contains object of action client class</p>

<p><pre class="highlight"><code class="language-python">class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''</code></pre>
</br></p>
<p style="background: AliceBlue">Constructor of class Ur5Moveit</p>

<p><pre class="highlight"><code class="language-python">    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5_ur5_2', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'
        self.pkg_name = None
        self.pick_condition = 0
        self.placed_order = {}
        self.package_order = {}
        self.lst_red = []
        self.lst_green = []
        self.lst_yellow = []

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))
        rospy.loginfo('\033[94m' + " &gt;&gt;&gt; Ur5Moveit init done." + '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.local_mqtt_sub_callback)</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Callback function called everytime mqtt topic receives new orders.</b></br>When there is an order passed to the local mqtt topic, this callback function is invoked. The message is decoded into a dictionary. Based on the key "item" of the dictionary, the recived orders are classified into seperate lists which will represent the color of the package, i.e Medicine ~ Red, Food ~ Yellow, Clothes ~Green. These lists are later used to sort into different bins based on the assigned color.</p>

<p><pre class="highlight"><code class="language-python">    def local_mqtt_sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print "PRINTING PAYLOAD FROM NEW NODE_T5_UR5_2", dict_payload
        # self.placed_order = dict_payload

        if dict_payload["item"] == "Medicine":
            self.lst_red.append(dict_payload)

        elif dict_payload["item"] == "Food":
            self.lst_yellow.append(dict_payload)

        elif dict_payload["item"] == "Clothes":
            self.lst_green.append(dict_payload)</code></pre>
</br></p>
<p style="background: AliceBlue">Clear Octomap</p>

<p><pre class="highlight"><code class="language-python">    def clear_octomap(self):
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns +
                                                         "/clear_octomap",
                                                         Empty)
        return clear_octomap_service_proxy()</code></pre>
</br></p>
<p style="background: AliceBlue">Function to set joint angles of arm with choice number of attempts</p>

<p><pre class="highlight"><code class="language-python">    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))</code></pre>
</br></p>
<p style="background: AliceBlue">Function to set Joint angles of the arm</p>

<p><pre class="highlight"><code class="language-python">    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Current Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        pose_values = self._group.get_current_pose().pose
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Pose:" + '\033[0m')
        rospy.loginfo(pose_values)

        if flag_plan:
            rospy.loginfo(
                '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Success" + '\033[0m')
        else:
            rospy.logerr(
                '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Failed." + '\033[0m')

        return flag_plan</code></pre>
</br></p>
<p style="background: AliceBlue">Plays pre recorded path</p>

<p><pre class="highlight"><code class="language-python">    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret</code></pre>
</br></p>
<p style="background: AliceBlue">Plays pre recorded paths with choice number of attempts</p>

<p><pre class="highlight"><code class="language-python">    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True</code></pre>
</br></p>
<p style="background: AliceBlue">Attaches/Detaches packages to vacuum gripper</p>

<p><pre class="highlight"><code class="language-python">    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach" </code></pre>
</br></p>
<p style="background: AliceBlue">Starts and stops conveyor by calling the service</p>

<p><pre class="highlight"><code class="language-python">    # Function definition to start and stop conveyor
    def start_or_stop_conveyor(self, power=0):
        '''Starts and stops conveyor by calling the service'''

        rospy.wait_for_service('/eyrc/vb/conveyor/set_power')
        try:
            start = rospy.ServiceProxy('/eyrc/vb/conveyor/set_power',
                                       conveyorBeltPowerMsg)
            start1 = start(power)
            return start1.result
        except:
            print "Service failed for conveyor"</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Callback for logical camera 2</b></br>This callback is invoked when the logical camera detects any external packages below it (Other than the conveyor belt). The function recieves the information as an argument and stored in msg.</br>If the list is not empty then check for the current position of the package, if it reaches directly below the camera this indicates the package is in the right position so that the arm can perform picking, The pick condition is enabled. Once the package goes out of range of the camera, the pick condition is disabled to allow picking of subsequent packages.
</p>

<p><pre class="highlight"><code class="language-python">    # Call back function definition
    def sub_callback(self, msg):
        '''Callback for logical camera 2'''

        # If Red package is detcted
        self.pkg_lst = ["packagen00", "packagen01", "packagen02", "packagen10",
                        "packagen11", "packagen12", "packagen20", "packagen21",
                        "packagen22", "packagen30", "packagen31", "packagen32"]

        try:

            self.pkg_name = msg.models[-1].type

            if msg.models != []:
                yn = msg.models[-1].pose.position.y
                xn = msg.models[-1].pose.position.x
                if yn &lt;= 0:  # Check if package is below logical_camera_2
                    self.pick_condition = 1
                else:
                    self.pick_condition = 0
        except:
            pass</code></pre>
</br></p>
<p style="background: AliceBlue">Deletes object of class</p>

<p><pre class="highlight"><code class="language-python">    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Main function declaration</b></br>A buffer time of 20 seconds is given so that the boxes are spawned properly. Classes are initialized and the conveyor is started. The subscriber for logical camera 2 is declared. After succesful detection of all 12 packages the topic from 2D Camera is unsubscribed.</br>From the dictionary containing the detected packages via the 2D Camera, based on the key "item" of the dictionary parameters are extracted and encoded as a json string to send to action server as a goal. This repeated for all detected packages , hence the inventory sheet is updated.</br>For the sorting action , pick condition is checked along with the color of the detected package under logical camera 2, based on both conditions the control flow is directed to appropriate block. Once placed into bins, goal as shipped is sent to the action server.
The order which has finished processing is popped from the list previously defined.
The same process is repetaed for other twp colors.
</p>

<p><pre class="highlight"><code class="language-python">def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ur5.start_or_stop_conveyor(100)

    ic = Camera1()

    rospy.sleep(2)

    attach_flag_red = 0
    attach_flag_green = 0
    attach_flag_yellow = 0

    rospy.Subscriber("/eyrc/vb/logical_camera_2", LogicalCameraImage,
                     ur5.sub_callback)

    rospy.sleep(5)

    ic.unsubscribe()

    for item in ic.dictorder.items():
        if item[1] == "red":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "R" +
                          str(item[0][-2:])+strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Medicine",
                          "Priority": "HP", "Storage Number": "R" +
                          str(item[0][-2]) +" C"+str(item[0][-1]),
                          "Cost": 450, "Quantity": 1}
            mesg = json.dumps(parameters)
            # sending message to bridge server
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

        elif item[1] == "yellow":
            # defining our sheet name in the 'id' variable and
            # the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "Y" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Food",
                          "Priority": "MP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 250, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

        elif item[1] == "green":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "G" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Clothes",
                          "Priority": "LP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 150, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

    box_length = 0.15               # Length of the Package
    vacuum_gripper_width = 0.115    # Vacuum Gripper Width
    delta = vacuum_gripper_width + (box_length/2)  # 0.19

    # Set, joints, angles definition for home position
    home_pos_list = [math.radians(7.838), math.radians(-139.943),
                     math.radians(-58.278), math.radians(-71.819),
                     math.radians(89.975), math.radians(7.833)]

    # Set, joints, angles definition for home position
    zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00),
                 math.radians(0.00), math.radians(0.00), math.radians(0.00)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    while not rospy.is_shutdown():
        package_name = ur5.pkg_name
        try:
            # Condition check; if package detected is red
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "red":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_red = ur5.attach_or_detach_to_vg(True)
                if attach_flag_red:
                    rospy.logwarn("1. Playing Home to Red bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_red_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_red[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_red.pop(0)
                    rospy.logwarn("2. Playing Red bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'red_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_red = 0

            # Condition check; if package detected is green
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "green":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_green = ur5.attach_or_detach_to_vg(True)
                if attach_flag_green:
                    rospy.logwarn("5. Playing Home to Green bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_green_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_green[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_green.pop(0)
                    rospy.logwarn("6. Playing Green Bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'green_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_green = 0

            # Condition check; if package detected is yellow
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "yellow":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_yellow = ur5.attach_or_detach_to_vg(True)
                if attach_flag_yellow:
                    rospy.logwarn("3. Playing Home to Yellow bin Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_yellow_bin_ur5_2.yaml', 5)  # Path from home pose to bin
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_yellow[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_yellow.pop(0)
                    rospy.logwarn("4. Playing Yellow bin to home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'yellow_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_yellow = 0

        except:
            pass

    del ur5</code></pre>
</br></p>
<p style="background: AliceBlue">Calling Main function</p>

<pre class="highlight"><code class="language-python">if __name__ == '__main__':
    main()</code></pre>
<p></br></p>
<p style="font-size: 20px"><b>Complete code of node_t5_ur5_2.py</b></p>

<p><pre class="highlight"><code class="language-python">#! /usr/bin/env python

import os
import math
import sys
import copy
import threading
import json

import time
from time import gmtime, strftime
from datetime import date, datetime, timedelta

import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
import actionlib
import rospkg
import yaml

import tf2_ros
import tf2_msgs.msg
from tf.transformations import euler_from_quaternion, quaternion_from_euler

import numpy as np
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

from pyzbar.pyzbar import decode

from std_srvs.srv import Empty

import requests

# Message Class used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotAction
# Message Class used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult
from pkg_ros_iot_bridge.msg import msgMqttSub

from pkg_vb_sim.srv import vacuumGripper
from pkg_vb_sim.srv import ConveyorBeltControl
from pkg_vb_sim.srv import conveyorBeltPowerMsg
from pkg_vb_sim.msg import LogicalCameraImage

import cv2


class IotRosBridgeActionClient:
    '''This class is responsible for using the node as an action client'''

    # Constructor
    def __init__(self):

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic']
        # Wait for Action Server that will use
        # the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")


    def on_transition(self, goal_handle):
        '''This function will be called when there is a change of 
        state in the Action Client State Machine'''

        # from on_goal() to on_transition(). goal_handle generated by
        # send_goal() is used here.
        result = msgRosIotResult()
        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " +
                      str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))
        # Comm State - Monitors the State Machine of the Client
        # which is different from Server's
        # Comm State = 2 -&gt; Active
        # Comm State = 3 -&gt; Wating for Result
        # Comm State = 7 -&gt; Done
        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")
        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " +
                              str(index))

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        '''This function is used to send Goals to Action Server'''

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")
        # self.on_transition - It is a function pointer to a
        # function which will be called when
        # there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle


class Camera1:
    '''This class performs image processing tasks'''

    def __init__(self):
        '''Constructor of class Camera1'''

        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber("/eyrc/vb/camera_1/image_raw",
                                          Image, self.callback)
        self.dictorder = {}

    # Qr Code decode function
    def get_qr_data(self, arg_image):
        '''Decodes the qr code'''

        qr_result = decode(arg_image)
        len_lst = len(qr_result)
        color_dict = {}

        print "LENGTH OF qr_result", len_lst

        for i in range(len_lst):
            if (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen00"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen01"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 290 and qr_result[i].rect[1] &lt;= 340):
                color_dict["packagen02"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen10"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen11"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 480 and qr_result[i].rect[1] &lt;= 520):
                color_dict["packagen12"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen20"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen21"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 630 and qr_result[i].rect[1] &lt;= 660):
                color_dict["packagen22"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 110 and qr_result[i].rect[0] &lt;= 150) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen30"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 300 and qr_result[i].rect[0] &lt;= 330) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen31"] = qr_result[i].data
            elif (qr_result[i].rect[0] &gt;= 490 and qr_result[i].rect[0] &lt;= 520) and (qr_result[i].rect[1] &gt;= 780 and qr_result[i].rect[1] &lt;= 810):
                color_dict["packagen32"] = qr_result[i].data

        # print("FINAL DICTIONAR LIST", color_dict)

        return color_dict

    # Function definition to unsubscribe from a topic
    def unsubscribe(self):
        '''Unsubscriber function used to unsubscribe from topics'''

        # use the saved subscriber object to unregister the subscriber
        self.image_sub.unregister()

    # Call back function definition
    def callback(self, data):
        '''Callback function called everytime 2D Camera sends data'''

        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")

        except CvBridgeError as e:
            rospy.logerr(e)

        # (rows, cols, channels) = cv_image.shape

        contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0)

        dst = cv2.fastNlMeansDenoisingColored(contrast_img, None,
                                              20, 25, 7, 21)

        image = dst

        # Resize a 720x1280 image to 360x640 to fit it on the screen
        # resized_image = cv2.resize(image, (720/2, 1280/2))

        # cv2.imshow("/eyrc/vb/camera_1/image_raw", resized_image)

        self.dictorder = self.get_qr_data(image)

        print "PACKAGE ORDER", self.dictorder

        # rospy.loginfo(self.get_qr_data(image))

        cv2.waitKey(1)


class Ur5Moveit:
    '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class'''

    # Constructor
    def __init__(self, arg_robot_name):
        '''Constructor of class Ur5Moveit'''

        rospy.init_node('node_t5_ur5_2', anonymous=True)

        self._robot_ns = '/' + arg_robot_name
        self._planning_group = "manipulator"

        self._commander = moveit_commander.roscpp_initialize(sys.argv)
        self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns)
        self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + "/robot_description", ns=self._robot_ns)
        self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1)
        self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction)
        self._exectute_trajectory_client.wait_for_server()

        self._planning_frame = self._group.get_planning_frame()
        self._eef_link = self._group.get_end_effector_link()
        self._group_names = self._robot.get_group_names()
        self._box_name = 'box'
        self.pkg_name = None
        self.pick_condition = 0
        self.placed_order = {}
        self.package_order = {}
        self.lst_red = []
        self.lst_green = []
        self.lst_yellow = []

        # Attribute to store computed trajectory by the planner
        self._computed_plan = ''

        # Current State of the Robot is needed to add box to planning scene
        self._curr_state = self._robot.get_current_state()

        rospy.loginfo(
            '\033[94m' + "Planning Group: {}".format(self._planning_frame) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "End Effector Link: {}".format(self._eef_link) +
            '\033[0m')
        rospy.loginfo(
            '\033[94m' + "Group Names: {}".format(self._group_names) +
            '\033[0m')

        rp = rospkg.RosPack()
        self._pkg_path = rp.get_path('pkg_task5')
        self._file_path = self._pkg_path + '/config/saved_trajectories/'
        rospy.loginfo("Package Path: {}".format(self._file_path))
        rospy.loginfo('\033[94m' + " &gt;&gt;&gt; Ur5Moveit init done." + '\033[0m')

        # DECLARING OBJECT OF ACTION CLASS HERE
        self.action_client = IotRosBridgeActionClient()

        # define variable for updating handle values
        self.i = 0

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print param_config_iot

        rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub,
                         self.local_mqtt_sub_callback)

    def local_mqtt_sub_callback(self, msg):
        '''Callback function called everytime mqtt topic receives new orders'''

        payload = msg.message
        dict_payload = json.loads(payload)
        print "PRINTING PAYLOAD FROM NEW NODE_T5_UR5_2", dict_payload
        # self.placed_order = dict_payload

        if dict_payload["item"] == "Medicine":
            self.lst_red.append(dict_payload)

        elif dict_payload["item"] == "Food":
            self.lst_yellow.append(dict_payload)

        elif dict_payload["item"] == "Clothes":
            self.lst_green.append(dict_payload)


    def clear_octomap(self):
        clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns +
                                                         "/clear_octomap",
                                                         Empty)
        return clear_octomap_service_proxy()

    def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts):
        '''Function to set joint angles of arm with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.set_joint_angles(arg_list_joint_angles)
            rospy.logwarn("attempts: {}".format(number_attempts))

    def set_joint_angles(self, arg_list_joint_angles):
        '''Function to set Joint angles of the arm'''

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Current Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        self._group.set_joint_value_target(arg_list_joint_angles)
        self._group.plan()
        flag_plan = self._group.go(wait=True)

        list_joint_values = self._group.get_current_joint_values()
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Joint Values:" + '\033[0m')
        rospy.loginfo(list_joint_values)

        pose_values = self._group.get_current_pose().pose
        rospy.loginfo('\033[94m' + "&gt;&gt;&gt; Final Pose:" + '\033[0m')
        rospy.loginfo(pose_values)

        if flag_plan:
            rospy.loginfo(
                '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Success" + '\033[0m')
        else:
            rospy.logerr(
                '\033[94m' + "&gt;&gt;&gt; set_joint_angles() Failed." + '\033[0m')

        return flag_plan

    def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name):
        '''Plays pre recorded path'''

        file_path = arg_file_path + arg_file_name

        with open(file_path, 'r') as file_open:
            loaded_plan = yaml.load(file_open)

        ret = self._group.execute(loaded_plan)
        # rospy.logerr(ret)
        return ret

    def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts):
        '''Plays pre recorded paths with choice number of attempts'''

        number_attempts = 0
        flag_success = False

        while ((number_attempts &lt;= arg_max_attempts) and (flag_success is False)):
            number_attempts += 1
            flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name)
            rospy.logwarn("attempts: {}".format(number_attempts))
            # # self.clear_octomap()

        return True

    # Function definition to attach or detach package to vacuumGripper
    def attach_or_detach_to_vg(self, vg_flag=False):
        '''Attaches/Detaches packages to vacuum gripper'''

        rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2')
        try:
            grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2', vacuumGripper)
            grip1 = grip(vg_flag)
            return grip1.result
        except:
            print "Service call failed for attach"   

    # Function definition to start and stop conveyor
    def start_or_stop_conveyor(self, power=0):
        '''Starts and stops conveyor by calling the service'''

        rospy.wait_for_service('/eyrc/vb/conveyor/set_power')
        try:
            start = rospy.ServiceProxy('/eyrc/vb/conveyor/set_power',
                                       conveyorBeltPowerMsg)
            start1 = start(power)
            return start1.result
        except:
            print "Service failed for conveyor"

    # Call back function definition
    def sub_callback(self, msg):
        '''Callback for logical camera 2'''

        # If Red package is detcted
        self.pkg_lst = ["packagen00", "packagen01", "packagen02", "packagen10",
                        "packagen11", "packagen12", "packagen20", "packagen21",
                        "packagen22", "packagen30", "packagen31", "packagen32"]

        try:

            self.pkg_name = msg.models[-1].type

            if msg.models != []:
                yn = msg.models[-1].pose.position.y
                xn = msg.models[-1].pose.position.x
                if yn &lt;= 0:  # Check if package is below logical_camera_2
                    self.pick_condition = 1
                else:
                    self.pick_condition = 0
        except:
            pass

    # Destructor
    def __del__(self):
        '''Deletes object of class'''

        moveit_commander.roscpp_shutdown()
        rospy.loginfo(
            '\033[94m' + "Object of class Ur5Moveit Deleted." + '\033[0m')


def main():

    rospy.sleep(20)

    ur5 = Ur5Moveit(sys.argv[1])

    ur5.start_or_stop_conveyor(100)

    ic = Camera1()

    rospy.sleep(2)

    attach_flag_red = 0
    attach_flag_green = 0
    attach_flag_yellow = 0

    rospy.Subscriber("/eyrc/vb/logical_camera_2", LogicalCameraImage,
                     ur5.sub_callback)

    rospy.sleep(5)

    ic.unsubscribe()

    for item in ic.dictorder.items():
        if item[1] == "red":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "R" +
                          str(item[0][-2:])+strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Medicine",
                          "Priority": "HP", "Storage Number": "R" +
                          str(item[0][-2]) +" C"+str(item[0][-1]),
                          "Cost": 450, "Quantity": 1}
            mesg = json.dumps(parameters)
            # sending message to bridge server
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

        elif item[1] == "yellow":
            # defining our sheet name in the 'id' variable and
            # the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "Y" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Food",
                          "Priority": "MP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 250, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

        elif item[1] == "green":
            # defining our sheet name in the 'id' variable and the the column where we want to update the value
            parameters = {"id": "Inventory", "Team Id": "VB#0302",
                          "Unique Id": "JAADjaad", "SKU": "G" +
                          str(item[0][-2:]) + strftime("%m", gmtime()) +
                          strftime("%y", gmtime()), "Item": "Clothes",
                          "Priority": "LP", "Storage Number": "R" +
                          str(item[0][-2]) + " C"+str(item[0][-1]),
                          "Cost": 150, "Quantity": 1}
            mesg = json.dumps(parameters)
            goal_handle = ur5.action_client.send_goal("mqtt", "pub_inventory", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
            # updating goal handle
            ur5.action_client._goal_handles[ur5.i] = goal_handle
            ur5.i += 1
            rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
            rospy.sleep(1)

    box_length = 0.15               # Length of the Package
    vacuum_gripper_width = 0.115    # Vacuum Gripper Width
    delta = vacuum_gripper_width + (box_length/2)  # 0.19

    # Set, joints, angles definition for home position
    home_pos_list = [math.radians(7.838), math.radians(-139.943),
                     math.radians(-58.278), math.radians(-71.819),
                     math.radians(89.975), math.radians(7.833)]

    # Set, joints, angles definition for home position
    zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00),
                 math.radians(0.00), math.radians(0.00), math.radians(0.00)]

    ur5.hard_set_joint_angles(home_pos_list, 5)

    while not rospy.is_shutdown():
        package_name = ur5.pkg_name
        try:
            # Condition check; if package detected is red
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "red":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_red = ur5.attach_or_detach_to_vg(True)
                if attach_flag_red:
                    rospy.logwarn("1. Playing Home to Red bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_red_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_red[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_red.pop(0)
                    rospy.logwarn("2. Playing Red bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'red_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_red = 0

            # Condition check; if package detected is green
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "green":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_green = ur5.attach_or_detach_to_vg(True)
                if attach_flag_green:
                    rospy.logwarn("5. Playing Home to Green bin Trajectory File")
                    # Path from home pose to bin
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_green_bin_ur5_2.yaml', 5)
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_green[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_green.pop(0)
                    rospy.logwarn("6. Playing Green Bin to Home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'green_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_green = 0

            # Condition check; if package detected is yellow
            if ur5.pick_condition == 1 and ic.dictorder[package_name] == "yellow":
                ur5.start_or_stop_conveyor(0)
                ur5.hard_set_joint_angles(home_pos_list, 5)
                # Attach package
                attach_flag_yellow = ur5.attach_or_detach_to_vg(True)
                if attach_flag_yellow:
                    rospy.logwarn("3. Playing Home to Yellow bin Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_yellow_bin_ur5_2.yaml', 5)  # Path from home pose to bin
                    ur5.attach_or_detach_to_vg(False)
                    ur5.start_or_stop_conveyor(100)

                    mesg = json.dumps(ur5.lst_yellow[0])
                    goal_handle = ur5.action_client.send_goal("mqtt", "pub_ship", ur5.action_client._config_mqtt_pub_topic, mesg)    # sending message to bridge server
                    # updating goal handle
                    ur5.action_client._goal_handles[ur5.i] = goal_handle
                    ur5.i += 1
                    rospy.loginfo("Goal #" + str(ur5.i-1) + " Sent")
                    ur5.lst_yellow.pop(0)
                    rospy.logwarn("4. Playing Yellow bin to home Trajectory File")
                    ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'yellow_bin_to_home_ur5_2.yaml', 5)  # Path from bin to home pose
                    attach_flag_yellow = 0

        except:
            pass

    del ur5


if __name__ == '__main__':
    main()
</code></pre>
</br></p>
<h2 id="pkg_ros_iot_bridge"><h2 style="background: AntiqueWhite" align="left"><b>pkg_ros_iot_bridge</b></h2></h2>
<h3 id="1-iotpy"><h3>1) iot.py</h3></h3>
<p style="background: AliceBlue">Importing all the necessary standard libraries</p>

<p><pre class="highlight"><code class="language-python">from multiprocessing.dummy import Pool
import time
import requests

import sys
import paho.mqtt.client as mqtt #import the client1
from time import gmtime,strftime
from datetime import date,datetime,timedelta
import json
import pytz

IST = pytz.timezone('Asia/Kolkata')</code></pre>
</br></p>
<p style="background: AliceBlue">Clas definition</p>

<p><pre class="highlight"><code class="language-python">class print_colour:</code></pre>
</br></p>
<p style="background: AliceBlue">Declaring Global Variables</p>

<p><pre class="highlight"><code class="language-python">    ''' Declaring Global Variables'''
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'</code></pre>
</br></p>
<p style="background: AliceBlue">Function declaration for iot_callback</p>

<p><pre class="highlight"><code class="language-python"># -----------------  MQTT SUB -------------------
def iot_func_callback_sub(client, userdata, message):
    '''Function declaration for iot_callback'''
    print("message received " ,str(message.payload.decode("utf-8")))
    print("message topic=",message.topic)
    print("message qos=",message.qos)
    print("message retain flag=",message.retain)</code></pre>
</br></p>
<p style="background: AliceBlue">Function declaration to create threads for simulatneous operation</p>

<p><pre class="highlight"><code class="language-python">def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos):
    '''Function declaration to create threads for simulatneous operation'''
    try:

        mqtt_client = mqtt.Client()
        mqtt_client.on_message = arg_callback_func
        mqtt_client.connect(arg_broker_url, arg_broker_port)
        mqtt_client.subscribe(arg_mqtt_topic, arg_mqtt_qos)
        time.sleep(1) # wait
        # mqtt_client.loop_forever() # starts a blocking infinite loop
        mqtt_client.loop_start()    # starts a new thread
        return 0
    except:
        return -1</code></pre>
</br></p>
<p style="background: AliceBlue">Function declaration to publish to mqtt client</p>

<p><pre class="highlight"><code class="language-python"># -----------------  MQTT PUB -------------------
def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos):
    '''Function declaration to publish to mqtt client'''
    try:

        print(type(arg_mqtt_message))
        mqtt_client = mqtt.Client("mqtt_pub")
        mqtt_client.connect(arg_broker_url, arg_broker_port)
        mqtt_client.loop_start()
    #spred_sheet(arg_mqtt_message)
    #print("message was found",arg_mqtt_message)
        print("Publishing message to topic", arg_mqtt_message)
        mqtt_client.publish(arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos)
        time.sleep(0.1) # wait

        mqtt_client.loop_stop() #stop the loop
        return 0
    except:
        return -1</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Function declaration to publish to IncomingOrders Spredsheet</b></br>Upon receiving data from the action client, the action server calls on this function to implement the updating incoming order spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated.</p>

<p><pre class="highlight"><code class="language-python"># ---------------- SPREADSHEET UPDATION ------------------
def spred_sheet(var):
    '''Function declaration to publish to IncomingOrders Spredsheet'''
    print("DICTIONARY FROM iot.py:", var)

    if(var['item'] == 'Food'):
        priority = 'MP'
        cost = 250
    elif(var['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
    elif(var['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150

    parameters1 = {"id":"IncomingOrders", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":var['order_id'], "Order Date and Time":var['order_time'], "Item":var['item'], "Priority":priority, "OrderQuantity":var['qty'], "City":var['city'], "Longitude":var['lon'], "Latitude":var['lat'], "Cost":cost }
    parameters2 = {"id":"IncomingOrders", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":var['order_id'], "Order Date and Time":var['order_time'], "Item":var['item'], "Priority":priority, "OrderQuantity":var['qty'], "City":var['city'], "Longitude":var['lon'], "Latitude":var['lat'], "Cost":cost } 

    URL1 = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"           # Google Apps Script URL
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # Google Apps Script URL

    response_1 = requests.get(URL1, params=parameters1)
    response_2 = requests.get(URL2, params=parameters2)

    print(response_1.content)         # Update the parameters to sheet 
    print(response_2.content)         # Update the parameters to e_yantra sheet</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Function declaration to publish to OrdersDispatched Spredsheet</b></br>Upon receiving data from the action client, the action server calls on this function to implement the updating Orders_dispatched spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated.</p>

<p><pre class="highlight"><code class="language-python">def orders_dispatched(msg):
    '''Function declaration to publish to OrdersDispatched Spredsheet'''

    new_dict = json.loads(msg)

    if(new_dict['item'] == 'Food'):
        priority = 'MP'
        cost = 250
    elif(new_dict['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
    elif(new_dict['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150

    date_time = datetime.now(IST)

    parameters1 = {"id":"OrdersDispatched", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":new_dict['order_id'], "City":new_dict['city'], "Item":new_dict['item'],"Priority":priority,  "Cost":cost, "Dispatch Status":"YES", "Dispatch Quantity":new_dict['qty'], "Dispatch Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S")}
    parameters2 = {"id":"OrdersDispatched", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":new_dict['order_id'], "City":new_dict['city'], "Item":new_dict['item'],"Priority":priority,  "Cost":cost, "Dispatch Status":"YES", "Dispatch Quantity":new_dict['qty'], "Dispatch Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S")}    

    URL1 = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"           # Google Apps Script URL
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # E-yantra Google Apps Script URL

    response_1 = requests.get(URL1, params=parameters1)
    response_2 = requests.get(URL2, params=parameters2)

    print(response_1.content)         # Update the parameters to sheet
    print(response_2.content)         # Update the parameters to e_yantra sheet

    if(response_1.content == "success"):
        return 0
    else:
        return -1</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Function declaration to publish to Inventory Spredsheet</b></br>Upon receiving data from the action client, the action server calls on this function to implement the updating inventory spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated.</p>

<p><pre class="highlight"><code class="language-python">def inventory(msg):
    '''Function declaration to publish to Inventory Spredsheet'''
    new_dict = json.loads(msg)

    parameters = {"id":"Inventory", "Team Id":"VB#0302" , "Unique Id":"JAADjaad", "SKU":new_dict["SKU"], "Item":new_dict["Item"], "Priority":new_dict["Priority"], "Storage Number":new_dict["Storage Number"], "Cost":new_dict["Cost"], "Quantity":new_dict["Quantity"]}
    parameters2 = {"id":"Inventory", "Team Id":"VB#0302" , "Unique Id":"JAADjaad", "SKU":new_dict["SKU"], "Item":new_dict["Item"], "Priority":new_dict["Priority"], "Storage Number":new_dict["Storage Number"], "Cost":new_dict["Cost"], "Quantity":new_dict["Quantity"]} 

    URL = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # E-yantra Google Apps Script URL

    response = requests.get(URL, params=parameters)
    response_2 = requests.get(URL2, params=parameters2)

    print(response.content)
    print(response_2.content)

    if(response.content == "success"):
        return 0
    else:
        return -1</code></pre>
</br></p>
<p style="background: AliceBlue"><b>Function declaration to publish to OrdersShipped Spredsheet</b></br>Upon receiving data from the action client, the action server calls on this function to implement the updating Orders_shipped spreadsheet task. The Priority,cost and time delay are set based on the type of order recieved, the spreadsheet is updated.</p>

<pre class="highlight"><code class="language-python">def orders_shipped(msg):
    '''Function declaration to publish to OrdersShipped Spredsheet'''

    new_dict = json.loads(msg)

    if(new_dict['item'] == 'Food'):
        priority = 'MP'
        cost = 250
        t = 3
    elif(new_dict['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
        t = 1
    elif(new_dict['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150
        t = 5

    date_time = datetime.now(IST)

    parameters = {"id":"OrdersShipped", "Team Id":"VB#0302", "Unique Id":"JAADjaad",   "Order ID":new_dict["order_id"],    "City":new_dict["city"],    "Item":new_dict["item"],    "Priority":priority,    "Shipped Quantity":new_dict["qty"],    "Cost":cost,    "Shipped Status":"YES",  "Shipped Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S"),   "Estimated Time of Delivery":date.today() + timedelta(t)}
    parameters2 = {"id":"OrdersShipped", "Team Id":"VB#0302", "Unique Id":"JAADjaad",   "Order ID":new_dict["order_id"],    "City":new_dict["city"],    "Item":new_dict["item"],    "Priority":priority,    "Shipped Quantity":new_dict["qty"],    "Cost":cost,    "Shipped Status":"YES",  "Shipped Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S"),   "Estimated Time of Delivery":date.today() + timedelta(t)}

    URL = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"

    response = requests.get(URL, params=parameters)
    response_2 = requests.get(URL2, params=parameters2)

    print(response.content)
    print(response_2.content)

    if(response.content == "success"):
        return 0
    else:
        return -1</code></pre>
<p></br></p>
<p style="font-size: 20px"><b>Complete code of iot.py</b></p>

<pre class="highlight"><code class="language-python">from multiprocessing.dummy import Pool
import time
import requests

import sys
import paho.mqtt.client as mqtt #import the client1
from time import gmtime,strftime
from datetime import date,datetime,timedelta
import json
import pytz

IST = pytz.timezone('Asia/Kolkata')


class print_colour:
    ''' Declaring Global Variables'''
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


# -----------------  MQTT SUB -------------------
def iot_func_callback_sub(client, userdata, message):
    '''Function declaration for iot_callback'''
    print("message received " ,str(message.payload.decode("utf-8")))
    print("message topic=",message.topic)
    print("message qos=",message.qos)
    print("message retain flag=",message.retain)

def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos):
    '''Function declaration to create threads for simulatneous operation'''
    try:

        mqtt_client = mqtt.Client()
        mqtt_client.on_message = arg_callback_func
        mqtt_client.connect(arg_broker_url, arg_broker_port)
        mqtt_client.subscribe(arg_mqtt_topic, arg_mqtt_qos)
        time.sleep(1) # wait
        # mqtt_client.loop_forever() # starts a blocking infinite loop
        mqtt_client.loop_start()    # starts a new thread
        return 0
    except:
        return -1


# -----------------  MQTT PUB -------------------
def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos):
    '''Function declaration to publish to mqtt client'''
    try:

        print(type(arg_mqtt_message))
        mqtt_client = mqtt.Client("mqtt_pub")
        mqtt_client.connect(arg_broker_url, arg_broker_port)
        mqtt_client.loop_start()
    #spred_sheet(arg_mqtt_message)
    #print("message was found",arg_mqtt_message)
        print("Publishing message to topic", arg_mqtt_message)
        mqtt_client.publish(arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos)
        time.sleep(0.1) # wait

        mqtt_client.loop_stop() #stop the loop
        return 0
    except:
        return -1

# ---------------- SPREADSHEET UPDATION ------------------
def spred_sheet(var):
    '''Function declaration to publish to IncomingOrders Spredsheet'''
    print("DICTIONARY FROM iot.py:", var)

    if(var['item'] == 'Food'):
        priority = 'MP'
        cost = 250
    elif(var['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
    elif(var['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150

    parameters1 = {"id":"IncomingOrders", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":var['order_id'], "Order Date and Time":var['order_time'], "Item":var['item'], "Priority":priority, "OrderQuantity":var['qty'], "City":var['city'], "Longitude":var['lon'], "Latitude":var['lat'], "Cost":cost }
    parameters2 = {"id":"IncomingOrders", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":var['order_id'], "Order Date and Time":var['order_time'], "Item":var['item'], "Priority":priority, "OrderQuantity":var['qty'], "City":var['city'], "Longitude":var['lon'], "Latitude":var['lat'], "Cost":cost } 

    URL1 = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"           # Google Apps Script URL
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # Google Apps Script URL

    response_1 = requests.get(URL1, params=parameters1)
    response_2 = requests.get(URL2, params=parameters2)

    print(response_1.content)         # Update the parameters to sheet 
    print(response_2.content)         # Update the parameters to e_yantra sheet 

def orders_dispatched(msg):
    '''Function declaration to publish to OrdersDispatched Spredsheet'''

    new_dict = json.loads(msg)

    if(new_dict['item'] == 'Food'):
        priority = 'MP'
        cost = 250
    elif(new_dict['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
    elif(new_dict['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150

    date_time = datetime.now(IST)

    parameters1 = {"id":"OrdersDispatched", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":new_dict['order_id'], "City":new_dict['city'], "Item":new_dict['item'],"Priority":priority,  "Cost":cost, "Dispatch Status":"YES", "Dispatch Quantity":new_dict['qty'], "Dispatch Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S")}
    parameters2 = {"id":"OrdersDispatched", "Team Id":"VB#0302", "Unique Id":"JAADjaad", "Order ID":new_dict['order_id'], "City":new_dict['city'], "Item":new_dict['item'],"Priority":priority,  "Cost":cost, "Dispatch Status":"YES", "Dispatch Quantity":new_dict['qty'], "Dispatch Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S")}    

    URL1 = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"           # Google Apps Script URL
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # E-yantra Google Apps Script URL

    response_1 = requests.get(URL1, params=parameters1)
    response_2 = requests.get(URL2, params=parameters2)

    print(response_1.content)         # Update the parameters to sheet
    print(response_2.content)         # Update the parameters to e_yantra sheet

    if(response_1.content == "success"):
        return 0
    else:
        return -1


def inventory(msg):
    '''Function declaration to publish to Inventory Spredsheet'''
    new_dict = json.loads(msg)

    parameters = {"id":"Inventory", "Team Id":"VB#0302" , "Unique Id":"JAADjaad", "SKU":new_dict["SKU"], "Item":new_dict["Item"], "Priority":new_dict["Priority"], "Storage Number":new_dict["Storage Number"], "Cost":new_dict["Cost"], "Quantity":new_dict["Quantity"]}
    parameters2 = {"id":"Inventory", "Team Id":"VB#0302" , "Unique Id":"JAADjaad", "SKU":new_dict["SKU"], "Item":new_dict["Item"], "Priority":new_dict["Priority"], "Storage Number":new_dict["Storage Number"], "Cost":new_dict["Cost"], "Quantity":new_dict["Quantity"]} 

    URL = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"            # E-yantra Google Apps Script URL

    response = requests.get(URL, params=parameters)
    response_2 = requests.get(URL2, params=parameters2)

    print(response.content)
    print(response_2.content)

    if(response.content == "success"):
        return 0
    else:
        return -1

def orders_shipped(msg):
    '''Function declaration to publish to OrdersShipped Spredsheet'''

    new_dict = json.loads(msg)

    if(new_dict['item'] == 'Food'):
        priority = 'MP'
        cost = 250
        t = 3
    elif(new_dict['item'] == 'Medicine'):
        priority = 'HP'
        cost = 450
        t = 1
    elif(new_dict['item'] == 'Clothes'):
        priority = 'LP'
        cost = 150
        t = 5

    date_time = datetime.now(IST)

    parameters = {"id":"OrdersShipped", "Team Id":"VB#0302", "Unique Id":"JAADjaad",   "Order ID":new_dict["order_id"],    "City":new_dict["city"],    "Item":new_dict["item"],    "Priority":priority,    "Shipped Quantity":new_dict["qty"],    "Cost":cost,    "Shipped Status":"YES",  "Shipped Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S"),   "Estimated Time of Delivery":date.today() + timedelta(t)}
    parameters2 = {"id":"OrdersShipped", "Team Id":"VB#0302", "Unique Id":"JAADjaad",   "Order ID":new_dict["order_id"],    "City":new_dict["city"],    "Item":new_dict["item"],    "Priority":priority,    "Shipped Quantity":new_dict["qty"],    "Cost":cost,    "Shipped Status":"YES",  "Shipped Date and Time":date_time.strftime("%Y-%m-%d %H:%M:%S"),   "Estimated Time of Delivery":date.today() + timedelta(t)}

    URL = "https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"
    URL2 = "https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec"

    response = requests.get(URL, params=parameters)
    response_2 = requests.get(URL2, params=parameters2)

    print(response.content)
    print(response_2.content)

    if(response.content == "success"):
        return 0
    else:
        return -1
</code></pre>
<p></br></p>
<h3 id="2node_action_server_ros_iot_bridgepy"><h3>2)node_action_server_ros_iot_bridge.py</h3></h3>
<p style="background: AliceBlue">Importing all the standard libraries</p>

<p><pre class="highlight"><code class="language-python">#!/usr/bin/env python

# ROS Node - Action Server -  ROS IoT Bridge

import rospy
import actionlib
import threading
import json

from pkg_ros_iot_bridge.msg import msgRosIotAction      # Message Class that is used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal        # Message Class that is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult      # Message Class that is used for Result Messages
from pkg_ros_iot_bridge.msg import msgRosIotFeedback    # Message Class that is used for Feedback Messages    

from pkg_ros_iot_bridge.msg import msgMqttSub           # Message Class for MQTT Subscription Messages

from pyiot import iot                                   # Custom Python Module to perfrom MQTT Tasks
</code></pre>
</br></p>
<p style="background: AliceBlue">This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics</p>

<p><pre class="highlight"><code class="language-python">class RosIotBridgeActionServer:
    '''This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics'''</code></pre>
</br></p>
<p style="background: AliceBlue">Constructor function definition for RosIotBridgeActionServer</p>

<p><pre class="highlight"><code class="language-python"># Constructor
    def __init__(self):
        '''Constructor function definition for RosIotBridgeActionServer'''
        # Initialize the Action Server
        self._as = actionlib.ActionServer('/action_ros_iot',
                                          msgRosIotAction,
                                          self.on_goal,
                                          self.on_cancel,
                                          auto_start=False)

        '''
            * self.on_goal - It is the fuction pointer which points to a function which will be called
                             when the Action Server receives a Goal.

            * self.on_cancel - It is the fuction pointer which points to a function which will be called
                             when the Action Server receives a Cancel Request.
        '''

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print(param_config_iot)


        # Initialize ROS Topic Publication
        # Incoming message from MQTT Subscription will be published on a ROS Topic (/ros_iot_bridge/mqtt/sub).
        # ROS Nodes can subscribe to this ROS Topic (/ros_iot_bridge/mqtt/sub) to get messages from MQTT Subscription.
        self._handle_ros_pub = rospy.Publisher(self._config_mqtt_sub_cb_ros_topic, msgMqttSub, queue_size=10)


        # Subscribe to MQTT Topic (eyrc/xYzqLm/iot_to_ros) which is defined in 'config_iot_ros.yaml'.
        # self.mqtt_sub_callback() function will be called when there is a message from MQTT Subscription.
        ret = iot.mqtt_subscribe_thread_start(  self.mqtt_sub_callback, 
                                                        self._config_mqtt_server_url, 
                                                        self._config_mqtt_server_port, 
                                                        self._config_mqtt_getting_orders, 
                                                        self._config_mqtt_qos   )
        if(ret == 0):
            rospy.loginfo("MQTT Subscribe Thread Started")
        else:
            rospy.logerr("Failed to start MQTT Subscribe Thread")


        # Start the Action Server
        self._as.start()

        rospy.loginfo("Started ROS-IoT Bridge Action Server.")</code></pre>
</br></p>
<p style="background: AliceBlue"><b>This is a callback function for MQTT Subscriptions</b></br>Upon reception of order from the internet this function publishes the same on the local topic so that the ros nodes can access the orders. This function also calls the function defined in iot,py to update the incoming orders spreadsheet.</p>

<p><pre class="highlight"><code class="language-python">    def mqtt_sub_callback(self, client, userdata, message):
        '''This is a callback function for MQTT Subscriptions'''
        payload = str(message.payload.decode("utf-8"))

        print("[MQTT SUB CB] Message: ", payload)
        print("[MQTT SUB CB] Topic: ", message.topic)
        dict_payload = json.loads(payload)
        iot.spred_sheet(dict_payload)

        msg_mqtt_sub = msgMqttSub()
        msg_mqtt_sub.timestamp = rospy.Time.now()
        msg_mqtt_sub.topic = message.topic
        msg_mqtt_sub.message = payload

        self._handle_ros_pub.publish(msg_mqtt_sub)</code></pre>
</br></p>
<p style="background: AliceBlue"><b>This function will be called when Action Server receives a Goal</b></br>Upon reception of a goal from the action clients, this function starts threading so that multiple goals can be processed simultaneously, the current goal is passed onto the process goal function.</p>

<p><pre class="highlight"><code class="language-python">    def on_goal(self, goal_handle):
        '''This function will be called when Action Server receives a Goal'''
        goal = goal_handle.get_goal()

        rospy.loginfo("Received new goal from Client")
        rospy.loginfo(goal)
        rospy.loginfo(goal.message)
        print(type(goal.message))
        # Validate incoming goal parameters
        if(goal.protocol == "mqtt"):

            if((goal.mode == "pub_dispatch") or (goal.mode == "sub") or (goal.mode == "pub_ship") or (goal.mode == "pub_inventory")):
                goal_handle.set_accepted()

                # Start a new thread to process new goal from the client (For Asynchronous Processing of Goals)
                # 'self.process_goal' - is the function pointer which points to a function that will process incoming Goals
                thread = threading.Thread(  name="worker",
                                            target=self.process_goal,
                                            args=(goal_handle,) )
                thread.start()

            else:
                goal_handle.set_rejected()
                return

        else:
            goal_handle.set_rejected()
            return</code></pre>
</br></p>
<p style="background: AliceBlue"><b>This function is called is a separate thread to process Goal</b></br>Upon reception of goal from on_goal, the function checks for the goal's mode parameter, this parameter is pre determined by the action client, and is set based on the requirement (dispatch, shipped, or inventory) based on the mode paramter appropriate functions from iot.py are called.</p>

<p><pre class="highlight"><code class="language-python">    def process_goal(self, goal_handle):
        '''Function to process the goal recieved from the action server'''

        flag_success = False
        result = msgRosIotResult()

        goal_id = goal_handle.get_goal_id()
        rospy.loginfo("Processing goal : " + str(goal_id.id))

        goal = goal_handle.get_goal()
        rospy.loginfo(goal)


        # Goal Processing
        if(goal.protocol == "mqtt"):
            rospy.logwarn("MQTT")

            if(goal.mode == "pub_dispatch"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                # ret = iot.mqtt_publish( self._config_mqtt_server_url, 
                #                         self._config_mqtt_server_port,
                #                         goal.topic, 
                #                         goal.message, 
                #                         self._config_mqtt_qos   )


                # if(ret == 0):
                #     rospy.loginfo("MQTT Publish Successful.")
                #     result.flag_success = True
                # else:
                #     rospy.logerr("MQTT Failed to Publish")
                #     result.flag_success = False
                rospy.loginfo("Publishing to dispatched spread sheet")
                ret = iot.orders_dispatched(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to dispatched Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to dispatched Spreadsheet!")
                    result.flag_success = False


            elif(goal.mode == "pub_inventory"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                rospy.loginfo("Publishing to inventory spread sheet")
                ret = iot.inventory(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to inventory Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to inventory Spreadsheet!")
                    result.flag_success = False


            elif(goal.mode == "pub_ship"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                rospy.loginfo("Publishing to shipped spread sheet")
                ret = iot.orders_shipped(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to shipped Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to shipped Spreadsheet!")
                    result.flag_success = False



            elif(goal.mode == "sub"):
                rospy.logwarn("MQTT SUB Goal ID: " + str(goal_id.id))
                rospy.logwarn(goal.topic)

                ret = iot.mqtt_subscribe_thread_start(  self.mqtt_sub_callback, 
                                                        self._config_mqtt_server_url, 
                                                        self._config_mqtt_server_port, 
                                                        goal.topic, 
                                                        self._config_mqtt_qos   )
                if(ret == 0):
                    rospy.loginfo("MQTT Subscribe Thread Started")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to start MQTT Subscribe Thread")
                    result.flag_success = False

        rospy.loginfo("Send goal result to client")
        if (result.flag_success == True):
            rospy.loginfo("Succeeded")
            goal_handle.set_succeeded(result)
        else:
            rospy.loginfo("Goal Failed. Aborting.")
            goal_handle.set_aborted(result)

        rospy.loginfo("Goal ID: " + str(goal_id.id) + " Goal Processing Done.")</code></pre>
</br></p>
<p style="background: AliceBlue">This function will be called when Goal Cancel request is send to the Action Server</p>

<p><pre class="highlight"><code class="language-python">    def on_cancel(self, goal_handle):
        '''Function which cancels the goal if required '''

        rospy.loginfo("Received cancel request.")
        goal_id = goal_handle.get_goal_id()</code></pre>
</br></p>
<p style="background: AliceBlue">Main function definition</p>

<p><pre class="highlight"><code class="language-python">def main():
    '''Main function definition'''
    rospy.init_node('node_iot_ros_bridge_action_server')

    action_server = RosIotBridgeActionServer()

    rospy.spin()</code></pre>
</br></p>
<p style="background: AliceBlue">Calling Main function</p>

<p><pre class="highlight"><code class="language-python">if __name__ == '__main__':
    '''Calling Main function'''
    main()</code></pre>
</br></p>
<p style="font-size: 20px"><b>Complete code of node_action_server_ros_iot_bridge.py</b></p>

<pre class="highlight"><code class="language-python">#!/usr/bin/env python

# ROS Node - Action Server -  ROS IoT Bridge

import rospy
import actionlib
import threading
import json

from pkg_ros_iot_bridge.msg import msgRosIotAction      # Message Class that is used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal        # Message Class that is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult      # Message Class that is used for Result Messages
from pkg_ros_iot_bridge.msg import msgRosIotFeedback    # Message Class that is used for Feedback Messages    

from pkg_ros_iot_bridge.msg import msgMqttSub           # Message Class for MQTT Subscription Messages

from pyiot import iot                                   # Custom Python Module to perfrom MQTT Tasks


class RosIotBridgeActionServer:
    '''This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics'''

    # Constructor
    def __init__(self):
        '''Constructor function definition for RosIotBridgeActionServer'''
        # Initialize the Action Server
        self._as = actionlib.ActionServer('/action_ros_iot',
                                          msgRosIotAction,
                                          self.on_goal,
                                          self.on_cancel,
                                          auto_start=False)

        '''
            * self.on_goal - It is the fuction pointer which points to a function which will be called
                             when the Action Server receives a Goal.

            * self.on_cancel - It is the fuction pointer which points to a function which will be called
                             when the Action Server receives a Cancel Request.
        '''

        # Read and Store IoT Configuration data from Parameter Server
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_server_url = param_config_iot['mqtt']['server_url']
        self._config_mqtt_server_port = param_config_iot['mqtt']['server_port']
        self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub']
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self._config_mqtt_qos = param_config_iot['mqtt']['qos']
        self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic']
        self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        print(param_config_iot)


        # Initialize ROS Topic Publication
        # Incoming message from MQTT Subscription will be published on a ROS Topic (/ros_iot_bridge/mqtt/sub).
        # ROS Nodes can subscribe to this ROS Topic (/ros_iot_bridge/mqtt/sub) to get messages from MQTT Subscription.
        self._handle_ros_pub = rospy.Publisher(self._config_mqtt_sub_cb_ros_topic, msgMqttSub, queue_size=10)


        # Subscribe to MQTT Topic (eyrc/xYzqLm/iot_to_ros) which is defined in 'config_iot_ros.yaml'.
        # self.mqtt_sub_callback() function will be called when there is a message from MQTT Subscription.
        ret = iot.mqtt_subscribe_thread_start(  self.mqtt_sub_callback, 
                                                        self._config_mqtt_server_url, 
                                                        self._config_mqtt_server_port, 
                                                        self._config_mqtt_getting_orders, 
                                                        self._config_mqtt_qos   )
        if(ret == 0):
            rospy.loginfo("MQTT Subscribe Thread Started")
        else:
            rospy.logerr("Failed to start MQTT Subscribe Thread")


        # Start the Action Server
        self._as.start()

        rospy.loginfo("Started ROS-IoT Bridge Action Server.")



    def mqtt_sub_callback(self, client, userdata, message):
        '''This is a callback function for MQTT Subscriptions'''
        payload = str(message.payload.decode("utf-8"))

        print("[MQTT SUB CB] Message: ", payload)
        print("[MQTT SUB CB] Topic: ", message.topic)
        dict_payload = json.loads(payload)
        iot.spred_sheet(dict_payload)

        msg_mqtt_sub = msgMqttSub()
        msg_mqtt_sub.timestamp = rospy.Time.now()
        msg_mqtt_sub.topic = message.topic
        msg_mqtt_sub.message = payload

        self._handle_ros_pub.publish(msg_mqtt_sub)



    def on_goal(self, goal_handle):
        '''This function will be called when Action Server receives a Goal'''
        goal = goal_handle.get_goal()

        rospy.loginfo("Received new goal from Client")
        rospy.loginfo(goal)
        rospy.loginfo(goal.message)
        print(type(goal.message))
        # Validate incoming goal parameters
        if(goal.protocol == "mqtt"):

            if((goal.mode == "pub_dispatch") or (goal.mode == "sub") or (goal.mode == "pub_ship") or (goal.mode == "pub_inventory")):
                goal_handle.set_accepted()

                # Start a new thread to process new goal from the client (For Asynchronous Processing of Goals)
                # 'self.process_goal' - is the function pointer which points to a function that will process incoming Goals
                thread = threading.Thread(  name="worker",
                                            target=self.process_goal,
                                            args=(goal_handle,) )
                thread.start()

            else:
                goal_handle.set_rejected()
                return

        else:
            goal_handle.set_rejected()
            return



    def process_goal(self, goal_handle):
        '''Function to process the goal recieved from the action server'''

        flag_success = False
        result = msgRosIotResult()

        goal_id = goal_handle.get_goal_id()
        rospy.loginfo("Processing goal : " + str(goal_id.id))

        goal = goal_handle.get_goal()
        rospy.loginfo(goal)


        # Goal Processing
        if(goal.protocol == "mqtt"):
            rospy.logwarn("MQTT")

            if(goal.mode == "pub_dispatch"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                # ret = iot.mqtt_publish( self._config_mqtt_server_url, 
                #                         self._config_mqtt_server_port,
                #                         goal.topic, 
                #                         goal.message, 
                #                         self._config_mqtt_qos   )


                # if(ret == 0):
                #     rospy.loginfo("MQTT Publish Successful.")
                #     result.flag_success = True
                # else:
                #     rospy.logerr("MQTT Failed to Publish")
                #     result.flag_success = False
                rospy.loginfo("Publishing to dispatched spread sheet")
                ret = iot.orders_dispatched(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to dispatched Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to dispatched Spreadsheet!")
                    result.flag_success = False


            elif(goal.mode == "pub_inventory"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                rospy.loginfo("Publishing to inventory spread sheet")
                ret = iot.inventory(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to inventory Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to inventory Spreadsheet!")
                    result.flag_success = False


            elif(goal.mode == "pub_ship"):
                rospy.logwarn("MQTT PUB Goal ID: " + str(goal_id.id))

                rospy.logwarn(goal.topic + " &gt; " + goal.message)

                rospy.loginfo("Publishing to shipped spread sheet")
                ret = iot.orders_shipped(goal.message)                # Invoking Spreadsheet update function written in file iot.py

                if(ret == 0):
                    rospy.loginfo("Successfully published to shipped Spreadsheet!")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to publish to shipped Spreadsheet!")
                    result.flag_success = False



            elif(goal.mode == "sub"):
                rospy.logwarn("MQTT SUB Goal ID: " + str(goal_id.id))
                rospy.logwarn(goal.topic)

                ret = iot.mqtt_subscribe_thread_start(  self.mqtt_sub_callback, 
                                                        self._config_mqtt_server_url, 
                                                        self._config_mqtt_server_port, 
                                                        goal.topic, 
                                                        self._config_mqtt_qos   )
                if(ret == 0):
                    rospy.loginfo("MQTT Subscribe Thread Started")
                    result.flag_success = True
                else:
                    rospy.logerr("Failed to start MQTT Subscribe Thread")
                    result.flag_success = False

        rospy.loginfo("Send goal result to client")
        if (result.flag_success == True):
            rospy.loginfo("Succeeded")
            goal_handle.set_succeeded(result)
        else:
            rospy.loginfo("Goal Failed. Aborting.")
            goal_handle.set_aborted(result)

        rospy.loginfo("Goal ID: " + str(goal_id.id) + " Goal Processing Done.")



    def on_cancel(self, goal_handle):
        '''This function will be called when Goal Cancel request is send to the Action Server'''
        rospy.loginfo("Received cancel request.")
        goal_id = goal_handle.get_goal_id()


def main():
    '''Main function definition'''
    rospy.init_node('node_iot_ros_bridge_action_server')

    action_server = RosIotBridgeActionServer()

    rospy.spin()



if __name__ == '__main__':
    '''Calling Main function'''
    main()
</code></pre>
<p></br></p>
<h3 id="3config_pyiotyaml"><h3>3)config_pyiot.yaml</h3></h3>
<p style="background: AliceBlue">config_pyiot.yaml contains all the parameters required to be accessed by all the nodes since it is published to parameter server.</p>

<p><pre class="highlight"><code class="language-python"># config_iot_ros.yaml 
# IoT Configuration
config_iot:
  mqtt:
    server_url: "broker.mqttdashboard.com"        # http://www.hivemq.com/demos/websocket-client/
    # server_url: "test.mosquitto.org"            # Alternative to HiveMQ
    server_port: 1883
    topic_sub: "eyrc/JAADjaad/iot_to_ros"          # &lt;unique_id&gt; = xYzqLm
    topic_pub: "eyrc/JAADjaad/ros_to_iot"          # &lt;unique_id&gt; = xYzqLm
    qos: 0

    getting_orders_topic: "/eyrc/vb/JAADjaad/orders"
    sub_cb_ros_topic: "/ros_iot_bridge/mqtt/sub"   # ROS nodes can listen to this topic to receive data from MQTT
  google_apps:
    spread_sheet_id: "AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec"
    e_yantra spread_sheet_id: "AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7"</code></pre>
</br></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../implementation/index.html" class="btn btn-neutral" title="Implementation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../implementation/index.html" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
