{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WELCOME TO eYRC-VB#0302 DOCUMENTATION Team Details Team ID : eYRC-VB#0302 Theme : Vargi Bots About Theme - Vargi Bot Inspired by this visualisation of Industry 4.0, the current edition of the e-Yantra Robotics Competition features a theme called \u2018Vargi-Bots\u2019. Vargi is taken from a Sanskrit word, Vargikaran (\u0935\u0930\u094d\u0917\u0940\u0915\u0930\u0923) which means to separate objects based on their category. The theme is set in the abstraction of a warehouse management system designed in Gazebo, which is a 3D dynamic simulator used to efficiently simulate robots in complex environments. The arena is an automated warehouse setting where essential packages are required to be sent out to different parts of a city. Since Industry 4.0 heavily focuses on automation here the warehouse will only consist of two industrial robotic arms which will be used by the teams. As the requirements are sent to the warehouse, one robotic arm will identify the packages from a shelf and place them on a conveyor belt and the other robotic arm at the end of the conveyor belt will pick these objects from the conveyor and place them into bins. Each bin represents a destination for the package. As the packages are sent out from the warehouse there will also be alerts sent to the user via email notifying them about the package being shipped from the warehouse. The packages to be delivered have their own priorities. Packages having a higher priority are intended for a natural disaster or a pandemic situation. Other packages with lower priorities are for general purposes. Similar to a conductor in an orchestra, in this theme, the participants have to design their own conductor (controller) for their warehouse to make smart decisions in order to deliver high priority packages as quickly as possible. Introducton Overview and stages: Vargi Bot being the allttoed theme, we realized the problem statement given every week using ROS(Robot Operating System), GAZEBO (Open-source 3D robotics simulator) and Google App Scripting. We controlled robotic arm in Gazebo using Python scripts and Rviz planner. Project flow: Initially the packages in the shelf are detected using 2D Camera and the captured image feed is processed to detect the QR Code on each of the packages. Denoising of the image is done to get better quality image and to detect all 12 packages. Then the Inventory sheet of INVENTORY MANAGEMENT SYSTEM spreadsheet is updated. As and when the incoming orders are received, the IncomingOrdrs spredsheet is updated.The ur5_1 arm then picks packages according to incoming orders and the packages are placed on conveyor belt without colloiding with its environment. As soon as the package is placed on the conveyor belt, the OrdersDispatched spredshhet is updated and an alert mail is sent saying Order Dispatched with the order details. The conveyor belt carries the package to the ur5_2 arm which picks it and drops it in corresponding bins. As soon as the package is dropped into the bin, OrdersShipped spredsheet is updated and an alert mail is sent saying Order Shipped with the order details. The Dashboard spredsheet is updated time to time taking values from the other sheets. Dashboard webpage is created, wherein all the details with repect to orders are updated referencing from Dashboard spredsheet of INVENTORY MANAGEMENT SYSTEM. The location of orders are pointed on map using pointers of different colors: Red pointer : Neither Dispatched nor shipped Yellow pointer : Dispatched but not yet shipped Green pointer : Dispatched and shipped successfully The time taken to ship the orders (Time duration between Order time and Shiping time) is indicated using bar graph. Bar graph is indicated with Red, Yellow and Green for Medicine, Food and Clothes repectively. Implementation Video","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#team-details","text":"","title":"Team Details"},{"location":"#about-theme-vargi-bot","text":"","title":"About Theme - Vargi Bot"},{"location":"#introducton","text":"","title":"Introducton"},{"location":"#implementation-video","text":"","title":"Implementation Video"},{"location":"api_documentation/","text":"API DOCUMENTATION pkg_task5 1.node_t5.py Importing all the necessary standard libraries. This block imports all necessary header files required in the node. import os import math import sys import copy import threading import json import time from time import gmtime, strftime from datetime import date, datetime, timedelta import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg import actionlib import rospkg import yaml import tf2_ros import tf2_msgs.msg from tf.transformations import euler_from_quaternion, quaternion_from_euler import numpy as np from std_msgs.msg import String from sensor_msgs.msg import Image from cv_bridge import CvBridge, CvBridgeError from pyzbar.pyzbar import decode from std_srvs.srv import Empty import requests # Message Class used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotGoal from pkg_ros_iot_bridge.msg import msgRosIotResult from pkg_ros_iot_bridge.msg import msgMqttSub from pkg_vb_sim.srv import vacuumGripper from pkg_vb_sim.srv import ConveyorBeltControl from pkg_vb_sim.srv import conveyorBeltPowerMsg from pkg_vb_sim.msg import LogicalCameraImage import cv2 This class is responsible for using the node as an action client class IotRosBridgeActionClient: '''This class is responsible for using the node as an action client''' Constructor function of class IotRosBridgeActionClient. -This block saves all the values from parameter server onto variables to be used later. # Constructor def __init__(self): '''Constructor function of class IotRosBridgeActionClient''' # Initialize Action Client self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction) # Dictionary to Store all the goal handels self._goal_handles = {} # Store the MQTT Topic on which to Publish in a variable param_config_iot = rospy.get_param('config_iot') self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic'] # Wait for Action Server that will use the action # - '/action_iot_ros' to start self._ac.wait_for_server() rospy.loginfo(\"Action server up, we can send goals.\") This function will be called when there is a change of state in the Action Client State Machine def on_transition(self, goal_handle): '''This function will be called when there is a change of state in the Action Client State Machine''' # from on_goal() to on_transition(). goal_handle # generated by send_goal() is used here. result = msgRosIotResult() index = 0 for i in self._goal_handles: if self._goal_handles[i] == goal_handle: index = i break rospy.loginfo(\"Transition Callback. Client Goal Handle #: \" + str(index)) rospy.loginfo(\"Comm. State: \" + str(goal_handle.get_comm_state())) rospy.loginfo(\"Goal Status: \" + str(goal_handle.get_goal_status())) # Comm State - Monitors the State Machine of the Client # which is different from Server's # Comm State = 2 -> Active # Comm State = 3 -> Wating for Result # Comm State = 7 -> Done # if (Comm State == ACTIVE) if goal_handle.get_comm_state() == 2: rospy.loginfo(str(index) + \": Goal just went active.\") # if (Comm State == DONE) if goal_handle.get_comm_state() == 7: rospy.loginfo(str(index) + \": Goal is DONE\") rospy.loginfo(goal_handle.get_terminal_state()) # get_result() gets the result produced by the Action Server result = goal_handle.get_result() rospy.loginfo(result.flag_success) if result.flag_success is True: rospy.loginfo(\"Goal successfully completed. Client Goal Handle #: \" + str(index)) else: rospy.loginfo(\"Goal failed. Client Goal Handle #: \" + str(index)) This function is used to send Goals to Action Server. -As and when the action client function is called it send the recieved goal to the action server, this function has 4 arguments, containing information which is to be sent via the message file. # This function is used to send Goals to Action Server def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message): '''This function is used to send Goals to Action Server''' # Create a Goal Message object goal = msgRosIotGoal() goal.protocol = arg_protocol goal.mode = arg_mode goal.topic = arg_topic goal.message = arg_message rospy.loginfo(\"Send goal.\") # self.on_transition - It is a function pointer to a function # which will be called when there is a change of state # in the Action Client State Machine goal_handle = self._ac.send_goal(goal, self.on_transition, None) This class performs image processing tasks class Camera1: '''This class performs image processing tasks''' Constructor of class Camera1. -Initializes and subscribes to the 2D Camera topic. def __init__(self): '''Constructor of class Camera1''' self.bridge = CvBridge() self.image_sub = rospy.Subscriber(\"/eyrc/vb/camera_1/image_raw\", Image, self.callback) self.dictorder = {} print \"Camera1 initialized\" Decodes the QR code. This function gets the entire image as a set of data, this is passed to the decode() function, which returns a dictionary containing information regarding the positions and decoded color of the respective package. # Qr Code decode function def get_qr_data(self, arg_image): '''Decodes the qr code''' qr_result = decode(arg_image) len_lst = len(qr_result) color_dict = {} print(\"LENGTH OF qr_result\", len_lst) for i in range(len_lst): if ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen00\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen01\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen02\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen10\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen11\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen12\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen20\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen21\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen22\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen30\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen31\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen32\"] = qr_result[i].data return color_dict Unsubscriber function used to unsubscribe from topics # Function definition to unsubscribe from a topic def unsubscribe(self): '''Unsubscriber function used to unsubscribe from topics''' # use the saved subscriber object to unregister the subscriber self.image_sub.unregister() Callback function called everytime 2D Camera sends data. The image id obtained as a stream of data, to this two image processing functions under cv packages is applied this will vary the light densities and denoise the stream of image. The parameters passed in the denoising function determine quality of the denoised image. This denoised image is sent as an argument to get_qr_data() which then performs detection. # Call back function definition def callback(self, data): '''Callback function called everytime 2D Camera sends data''' print \"CALLBACK ENTERED\" try: cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") except CvBridgeError as e: rospy.logerr(e) # (rows, cols, channels) = cv_image.shape contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0) dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, 20, 25, 7, 21) image = dst # Resize a 720x1280 image to 360x640 to fit it on the screen # resized_image = cv2.resize(image, (720/2, 1280/2)) # cv2.imshow(\"/eyrc/vb/camera_1/image_raw\", resized_image) self.dictorder = self.get_qr_data(image) print(\"PACKAGE ORDER\", self.dictorder) cv2.waitKey(1) Main class that initializes the robot arms, configures MoveIt and contains object of action client class class Ur5Moveit: '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class''' Constructor of class Ur5Moveit The created constructor provides access to the attributes and methods of the class Ur5Moveit. This consists of \u2018 arg_robot_name\u2019 as an argument,which is later initialised from the \u2018main()\u2019 function as ur5 = Ur5Moveit(sys.argv[1]) The constructor also enables the subscription to a local topic.Multiple empty lists have been created which are later used for sorting/segregation purposes. # Constructor def __init__(self, arg_robot_name): '''Constructor of class Ur5Moveit''' rospy.init_node('node_t5', anonymous=True) self._robot_ns = '/' + arg_robot_name self._planning_group = \"manipulator\" self._commander = moveit_commander.roscpp_initialize(sys.argv) self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns) self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._group.set_planning_time(99) self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1) self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction) self._exectute_trajectory_client.wait_for_server() self._planning_frame = self._group.get_planning_frame() self._eef_link = self._group.get_end_effector_link() self._group_names = self._robot.get_group_names() self._box_name = 'box' # Attribute to store computed trajectory by the planner self._computed_plan = '' # Current State of the Robot is needed to add box to planning scene self._curr_state = self._robot.get_current_state() self.placed_order = [] self.placed_order_red =[] self.placed_order_yellow =[] self.placed_order_green =[] rospy.loginfo( '\\033[94m' + \"Planning Group: {}\".format(self._planning_frame) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"End Effector Link: {}\".format(self._eef_link) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"Group Names: {}\".format(self._group_names) + '\\033[0m') rp = rospkg.RosPack() self._pkg_path = rp.get_path('pkg_task5') self._file_path = self._pkg_path + '/config/saved_trajectories/' rospy.loginfo(\"Package Path: {}\".format(self._file_path)) rospy.loginfo('\\033[94m' + \" >>> Ur5Moveit init done.\" + '\\033[0m') # DECLARING OBJECT OF ACTION CLASS HERE self.action_client = IotRosBridgeActionClient() # define variable for updating handle values self.i = 0 # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print param_config_iot rospy.Subscriber(\"/ros_iot_bridge/mqtt/sub\", msgMqttSub, self.sub_callback) Callback function called everytime mqtt topic receives new orders This function consists of \u2018msg\u2019 as an argument to it. When , rospy.Subscriber(\"/ros_iot_bridge/mqtt/sub\", msgMqttSub, self.sub_callback) receives an order, \u2018msgMqttSub\u2019 is given as the argument for the sub_callback function. It contains 4 parameters, of which we need to access the \u2018message\u2019 parameter. A dictionary of the contents is created and items are appended to different lists based on their type to the respective colours. def sub_callback(self, msg): '''Callback function called everytime mqtt topic receives new orders''' payload = msg.message dict_payload = json.loads(payload) print(\"PRINTING PAYLOAD FROM NEW NODE_T5\", dict_payload) self.placed_order.append(dict_payload) if dict_payload['item'] == 'Medicine': self.placed_order_red.append(dict_payload) elif dict_payload['item'] == 'Food': self.placed_order_yellow.append(dict_payload) elif dict_payload['item'] == 'Clothes': self.placed_order_green.append(dict_payload) Clears the octomap def clear_octomap(self): '''Clears the octomap''' clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + \"/clear_octomap\", Empty) return clear_octomap_service_proxy() Function to set joint angles of arm with choice number of attempts This Function is used to set joint angles of arm with number of attempts. Here,a list of home positions is passed as arguments from the main function along with the number of attempts. def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): '''Function to set joint angles of arm with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.set_joint_angles(arg_list_joint_angles) rospy.logwarn(\"attempts: {}\".format(number_attempts)) Function to set Joint angles of the arm It is a function to set joint angles of the arm. This is called in the def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): function,and gives us the status of success/failed outcomes. def set_joint_angles(self, arg_list_joint_angles): '''Function to set Joint angles of the arm''' # list_joint_values = self._group.get_current_joint_values() # rospy.loginfo('\\033[94m' + \">>> Current Joint Values:\" + '\\033[0m') # rospy.loginfo(list_joint_values) self._group.set_joint_value_target(arg_list_joint_angles) self._group.plan() flag_plan = self._group.go(wait=True) list_joint_values = self._group.get_current_joint_values() # rospy.loginfo('\\033[94m' + \">>> Final Joint Values:\" + '\\033[0m') # rospy.loginfo(list_joint_values) # pose_values = self._group.get_current_pose().pose # rospy.loginfo('\\033[94m' + \">>> Final Pose:\" + '\\033[0m') # rospy.loginfo(pose_values) if flag_plan is True: pass # rospy.loginfo(# '\\033[94m' + \">>> set_joint_angles() Success\" +'\\033[0m') else: pass # rospy.logerr(# '\\033[94m' + \">>> set_joint_angles() Failed.\" + '\\033[0m') return flag_plan Plays pre recorded path def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): '''Plays pre recorded path''' file_path = arg_file_path + arg_file_name with open(file_path, 'r') as file_open: loaded_plan = yaml.load(file_open) ret = self._group.execute(loaded_plan) # rospy.logerr(ret) return ret Plays pre recorded paths with choice number of attempts def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): '''Plays pre recorded paths with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name) rospy.logwarn(\"attempts: {}\".format(number_attempts)) # # self.clear_octomap() return True Attaches/Detaches packages to vacuum gripper This function is used to attach or detach package to vacuumGripper.A try and except block is used to produce the result (grip1.result). If an error is obtained the code goes to the except block and displays \u201cService call failed for attach\". # Function definition to attach or detach package to vacuumGripper def attach_or_detach_to_vg(self, vg_flag=False): '''Attaches/Detaches packages to vacuum gripper''' rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1') try: grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1', vacuumGripper) grip1 = grip(vg_flag) return grip1.result except: print \"Service call failed for attach\" Deletes object of class # Destructor def __del__(self): '''Deletes object of class''' moveit_commander.roscpp_shutdown() rospy.loginfo( '\\033[94m' + \"Object of class Ur5Moveit Deleted.\" + '\\033[0m') Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments This function recieves two arguments package name and the current order. Based on the package name, the ur5_1 arm picks the corresponding package from the shelf and will place it on the conveyor belt. Subsequently a goal is sent to the action server that the package is dispatched. def func_packages(self, pkg_name, new_dict): '''Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments''' if pkg_name == \"packagen00\": # Picking Package 00 from the shelf all_zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00)] self.hard_set_joint_angles(all_zero_list, 5) rospy.logwarn(\"1. Playing AllZeros to Pose#1 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'zero_to_pkg1.yaml', 5) rospy.sleep(2) attach = self.attach_or_detach_to_vg(True) if attach: rospy.logwarn(\"2.Playing Packagen00 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen00_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle0 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle0 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen01\": # Picking Package 01 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_2 = 0 rospy.logwarn(\"1. Playing Home to Pkg2 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg2.yaml', 5) attached_2 = self.attach_or_detach_to_vg(True) if attached_2: rospy.logwarn(\"2.Playing Packagen01 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen01_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle1 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle1 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen02\": # Picking Package 02 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attched_3 = 0 rospy.logwarn(\"1. Playing Home to Pkg3 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg3.yaml', 5) attached_3 = self.attach_or_detach_to_vg(True) if attached_3: rospy.logwarn(\"1. Playing Pkg3 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen02_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle2 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle2 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen10\": # Picking Package 10 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_4 = 0 rospy.logwarn(\"1. Playing Home to Pkg4 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg4.yaml', 5) attached_4 = self.attach_or_detach_to_vg(True) if attached_4: rospy.logwarn(\"1. Playing Pkg4 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen10_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle3 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle3 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen11\": # Picking Package 11 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_5 = 0 rospy.logwarn(\"1. Playing Home to Pkg5 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg5.yaml', 5) attached_5 = self.attach_or_detach_to_vg(True) if attached_5: rospy.logwarn(\"1. Playing Pkg5 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen11_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle4 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle4 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen12\": # Picking Package 12 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_6 = 0 rospy.logwarn(\"1. Playing Home to Pkg6 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg6.yaml', 5) attached_6 = self.attach_or_detach_to_vg(True) if attached_6: rospy.logwarn(\"1. Playing Pkg6 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen12_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle5 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle5 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen30\": # Picking Package 30 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) rospy.logwarn(\"1. Playing Home to Pkg10 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg10.yaml', 5) attached_10 = 0 attached_10 = self.attach_or_detach_to_vg(True) if attached_10: rospy.logwarn(\"1. Playing Pkg10 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_to_cartesian_ALTERNATE.yaml', 5) rospy.logwarn(\"1. Playing Pkg10 cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_cartesian_to_home_ALTERNATE.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle6 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server self.action_client._goal_handles[self.i] = goal_handle6 # updating goal handle self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen31\": # Picking Package 31 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) rospy.logwarn(\"1. Playing Home to Pkg11 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg11.yaml', 5) attached_11 = 0 attached_11 = self.attach_or_detach_to_vg(True) if attached_11: rospy.logwarn(\"1. Playing Pkg11 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_to_cartesian_ALTERNATE.yaml', 5) rospy.logwarn(\"1. Playing Pkg11 cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_cartesian_to_home_ALTERNATE.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle7 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle7 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen32\": # Picking Package 32 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_12 = 0 rospy.logwarn(\"1. Playing Home to Pkg12 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg12.yaml', 5) attached_12 = self.attach_or_detach_to_vg(True) if attached_12: rospy.logwarn(\"1. Playing Pkg32 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_to_cartesian.yaml', 5) rospy.logwarn(\"1. Playing cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_cartesian_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle8 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle8 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") Main function declaration A buffer time of 20 seconds is provided for the packages to spawn. Initially all the detected packages on the shelf are grouped to three lists based on their colour. These lists are sorted in increasing order of their position in shelf. This is done in order to move from one end of the shelf. As when the orders are received, the order dictionaries are appended to a list in the callback function. Then the while loop checks for red first indicating high priority, then yellow and lastly for green package. Now suppose red package doesn't arrive, it'll continue with the next highest priority order. def main(): rospy.sleep(20) ur5 = Ur5Moveit(sys.argv[1]) ic = Camera1() lst_red = [] lst_green = [] lst_yellow = [] rospy.sleep(5) # Sort the detected packages into respective lists based on color dict_order_temp = ic.dictorder print \"PRINTING DICTORDER\", dict_order_temp for i in dict_order_temp.items(): if i[1] == \"red\": lst_red.append(i) print(\"PRINTING SEPERATELY\", lst_red) elif i[1] == \"yellow\": lst_yellow.append(i) elif i[1] == \"green\": lst_green.append(i) lst_red.sort(key=lambda x: x[0]) lst_yellow.sort(key=lambda x: x[0]) lst_green.sort(key=lambda x: x[0]) print \"PRINTING LISTS\", lst_red, lst_yellow, lst_green lst_red.pop(2) lst_yellow.pop(2) lst_green.pop(2) print \"POPPED LISTS\", lst_red, lst_yellow, lst_green ic.unsubscribe() # Define position above conveyor belt home_pos_list = [math.radians(7.838), math.radians(-139.943), math.radians(-58.278), math.radians(-71.819), math.radians(89.975), math.radians(7.833)] ur5.hard_set_joint_angles(home_pos_list, 5) # Used for traversing the list of dictionaries i = 0 while not rospy.is_shutdown(): if ur5.placed_order != []: while i < len(ur5.placed_order): if ur5.placed_order_red !=[]: print \"ENTERED RED IN MAIN\" var_flag = lst_red[0][0] ur5.func_packages(var_flag, ur5.placed_order_red[0]) ur5.placed_order_red.pop(0) lst_red.pop(0) i += 1 elif ur5.placed_order_yellow !=[]: var_flag = lst_yellow[0][0] ur5.func_packages(var_flag, ur5.placed_order_yellow[0]) ur5.placed_order_yellow.pop(0) lst_yellow.pop(0) i += 1 elif ur5.placed_order_green !=[]: var_flag = lst_green[0][0] print \"DETECTED GREEN\" ur5.func_packages(var_flag, ur5.placed_order_green[0]) ur5.placed_order_green.pop(0) lst_green.pop(0) i += 1 del ur5 Calling main function if __name__ == '__main__': main() Complete code of node_t5.py #! /usr/bin/env python import os import math import sys import copy import threading import json import time from time import gmtime, strftime from datetime import date, datetime, timedelta import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg import actionlib import rospkg import yaml import tf2_ros import tf2_msgs.msg from tf.transformations import euler_from_quaternion, quaternion_from_euler import numpy as np from std_msgs.msg import String from sensor_msgs.msg import Image from cv_bridge import CvBridge, CvBridgeError from pyzbar.pyzbar import decode from std_srvs.srv import Empty import requests # Message Class used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotGoal from pkg_ros_iot_bridge.msg import msgRosIotResult from pkg_ros_iot_bridge.msg import msgMqttSub from pkg_vb_sim.srv import vacuumGripper from pkg_vb_sim.srv import ConveyorBeltControl from pkg_vb_sim.srv import conveyorBeltPowerMsg from pkg_vb_sim.msg import LogicalCameraImage import cv2 class IotRosBridgeActionClient: '''This class is responsible for using the node as an action client''' # Constructor def __init__(self): '''Constructor function of class IotRosBridgeActionClient''' # Initialize Action Client self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction) # Dictionary to Store all the goal handels self._goal_handles = {} # Store the MQTT Topic on which to Publish in a variable param_config_iot = rospy.get_param('config_iot') self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic'] # Wait for Action Server that will use the action # - '/action_iot_ros' to start self._ac.wait_for_server() rospy.loginfo(\"Action server up, we can send goals.\") def on_transition(self, goal_handle): '''This function will be called when there is a change of state in the Action Client State Machine''' # from on_goal() to on_transition(). goal_handle # generated by send_goal() is used here. result = msgRosIotResult() index = 0 for i in self._goal_handles: if self._goal_handles[i] == goal_handle: index = i break rospy.loginfo(\"Transition Callback. Client Goal Handle #: \" + str(index)) rospy.loginfo(\"Comm. State: \" + str(goal_handle.get_comm_state())) rospy.loginfo(\"Goal Status: \" + str(goal_handle.get_goal_status())) # Comm State - Monitors the State Machine of the Client # which is different from Server's # Comm State = 2 -> Active # Comm State = 3 -> Wating for Result # Comm State = 7 -> Done # if (Comm State == ACTIVE) if goal_handle.get_comm_state() == 2: rospy.loginfo(str(index) + \": Goal just went active.\") # if (Comm State == DONE) if goal_handle.get_comm_state() == 7: rospy.loginfo(str(index) + \": Goal is DONE\") rospy.loginfo(goal_handle.get_terminal_state()) # get_result() gets the result produced by the Action Server result = goal_handle.get_result() rospy.loginfo(result.flag_success) if result.flag_success is True: rospy.loginfo(\"Goal successfully completed. Client Goal Handle #: \" + str(index)) else: rospy.loginfo(\"Goal failed. Client Goal Handle #: \" + str(index)) # This function is used to send Goals to Action Server def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message): '''This function is used to send Goals to Action Server''' # Create a Goal Message object goal = msgRosIotGoal() goal.protocol = arg_protocol goal.mode = arg_mode goal.topic = arg_topic goal.message = arg_message rospy.loginfo(\"Send goal.\") # self.on_transition - It is a function pointer to a function # which will be called when there is a change of state # in the Action Client State Machine goal_handle = self._ac.send_goal(goal, self.on_transition, None) return goal_handle class Camera1: '''This class performs image processing tasks''' def __init__(self): '''Constructor of class Camera1''' self.bridge = CvBridge() self.image_sub = rospy.Subscriber(\"/eyrc/vb/camera_1/image_raw\", Image, self.callback) self.dictorder = {} print \"Camera1 initialized\" # Qr Code decode function def get_qr_data(self, arg_image): '''Decodes the qr code''' qr_result = decode(arg_image) len_lst = len(qr_result) color_dict = {} print(\"LENGTH OF qr_result\", len_lst) for i in range(len_lst): if ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen00\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen01\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340)): color_dict[\"packagen02\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen10\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen11\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520)): color_dict[\"packagen12\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen20\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen21\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660)): color_dict[\"packagen22\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen30\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen31\"] = qr_result[i].data elif ((qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810)): color_dict[\"packagen32\"] = qr_result[i].data return color_dict # Function definition to unsubscribe from a topic def unsubscribe(self): '''Unsubscriber function used to unsubscribe from topics''' # use the saved subscriber object to unregister the subscriber self.image_sub.unregister() # Call back function definition def callback(self, data): '''Callback function called everytime 2D Camera sends data''' print \"CALLBACK ENTERED\" try: cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") except CvBridgeError as e: rospy.logerr(e) # (rows, cols, channels) = cv_image.shape contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0) dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, 20, 25, 7, 21) image = dst # Resize a 720x1280 image to 360x640 to fit it on the screen # resized_image = cv2.resize(image, (720/2, 1280/2)) # cv2.imshow(\"/eyrc/vb/camera_1/image_raw\", resized_image) self.dictorder = self.get_qr_data(image) print(\"PACKAGE ORDER\", self.dictorder) cv2.waitKey(1) class Ur5Moveit: '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class''' # Constructor def __init__(self, arg_robot_name): '''Constructor of class Ur5Moveit''' rospy.init_node('node_t5', anonymous=True) self._robot_ns = '/' + arg_robot_name self._planning_group = \"manipulator\" self._commander = moveit_commander.roscpp_initialize(sys.argv) self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns) self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._group.set_planning_time(99) self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1) self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction) self._exectute_trajectory_client.wait_for_server() self._planning_frame = self._group.get_planning_frame() self._eef_link = self._group.get_end_effector_link() self._group_names = self._robot.get_group_names() self._box_name = 'box' # Attribute to store computed trajectory by the planner self._computed_plan = '' # Current State of the Robot is needed to add box to planning scene self._curr_state = self._robot.get_current_state() self.placed_order = [] self.placed_order_red =[] self.placed_order_yellow =[] self.placed_order_green =[] rospy.loginfo( '\\033[94m' + \"Planning Group: {}\".format(self._planning_frame) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"End Effector Link: {}\".format(self._eef_link) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"Group Names: {}\".format(self._group_names) + '\\033[0m') rp = rospkg.RosPack() self._pkg_path = rp.get_path('pkg_task5') self._file_path = self._pkg_path + '/config/saved_trajectories/' rospy.loginfo(\"Package Path: {}\".format(self._file_path)) rospy.loginfo('\\033[94m' + \" >>> Ur5Moveit init done.\" + '\\033[0m') # DECLARING OBJECT OF ACTION CLASS HERE self.action_client = IotRosBridgeActionClient() # define variable for updating handle values self.i = 0 # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print param_config_iot rospy.Subscriber(\"/ros_iot_bridge/mqtt/sub\", msgMqttSub, self.sub_callback) def sub_callback(self, msg): '''Callback function called everytime mqtt topic receives new orders''' payload = msg.message dict_payload = json.loads(payload) print(\"PRINTING PAYLOAD FROM NEW NODE_T5\", dict_payload) self.placed_order.append(dict_payload) if dict_payload['item'] == 'Medicine': self.placed_order_red.append(dict_payload) elif dict_payload['item'] == 'Food': self.placed_order_yellow.append(dict_payload) elif dict_payload['item'] == 'Clothes': self.placed_order_green.append(dict_payload) def clear_octomap(self): '''Clears the octomap''' clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + \"/clear_octomap\", Empty) return clear_octomap_service_proxy() def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): '''Function to set joint angles of arm with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.set_joint_angles(arg_list_joint_angles) rospy.logwarn(\"attempts: {}\".format(number_attempts)) def set_joint_angles(self, arg_list_joint_angles): '''Function to set Joint angles of the arm''' # list_joint_values = self._group.get_current_joint_values() # rospy.loginfo('\\033[94m' + \">>> Current Joint Values:\" + '\\033[0m') # rospy.loginfo(list_joint_values) self._group.set_joint_value_target(arg_list_joint_angles) self._group.plan() flag_plan = self._group.go(wait=True) list_joint_values = self._group.get_current_joint_values() # rospy.loginfo('\\033[94m' + \">>> Final Joint Values:\" + '\\033[0m') # rospy.loginfo(list_joint_values) # pose_values = self._group.get_current_pose().pose # rospy.loginfo('\\033[94m' + \">>> Final Pose:\" + '\\033[0m') # rospy.loginfo(pose_values) if flag_plan is True: pass # rospy.loginfo(# '\\033[94m' + \">>> set_joint_angles() Success\" +'\\033[0m') else: pass # rospy.logerr(# '\\033[94m' + \">>> set_joint_angles() Failed.\" + '\\033[0m') return flag_plan def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): '''Plays pre recorded path''' file_path = arg_file_path + arg_file_name with open(file_path, 'r') as file_open: loaded_plan = yaml.load(file_open) ret = self._group.execute(loaded_plan) # rospy.logerr(ret) return ret def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): '''Plays pre recorded paths with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name) rospy.logwarn(\"attempts: {}\".format(number_attempts)) # # self.clear_octomap() return True # Function definition to attach or detach package to vacuumGripper def attach_or_detach_to_vg(self, vg_flag=False): '''Attaches/Detaches packages to vacuum gripper''' rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1') try: grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_1', vacuumGripper) grip1 = grip(vg_flag) return grip1.result except: print \"Service call failed for attach\" # Destructor def __del__(self): '''Deletes object of class''' moveit_commander.roscpp_shutdown() rospy.loginfo( '\\033[94m' + \"Object of class Ur5Moveit Deleted.\" + '\\033[0m') def func_packages(self, pkg_name, new_dict): '''Goes to package on shelf based on orders recieved takes package name and orders dictionary as arguments''' if pkg_name == \"packagen00\": # Picking Package 00 from the shelf all_zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00)] self.hard_set_joint_angles(all_zero_list, 5) rospy.logwarn(\"1. Playing AllZeros to Pose#1 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'zero_to_pkg1.yaml', 5) rospy.sleep(2) attach = self.attach_or_detach_to_vg(True) if attach: rospy.logwarn(\"2.Playing Packagen00 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen00_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle0 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle0 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen01\": # Picking Package 01 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_2 = 0 rospy.logwarn(\"1. Playing Home to Pkg2 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg2.yaml', 5) attached_2 = self.attach_or_detach_to_vg(True) if attached_2: rospy.logwarn(\"2.Playing Packagen01 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen01_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle1 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle1 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen02\": # Picking Package 02 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attched_3 = 0 rospy.logwarn(\"1. Playing Home to Pkg3 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg3.yaml', 5) attached_3 = self.attach_or_detach_to_vg(True) if attached_3: rospy.logwarn(\"1. Playing Pkg3 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen02_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle2 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle2 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen10\": # Picking Package 10 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_4 = 0 rospy.logwarn(\"1. Playing Home to Pkg4 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg4.yaml', 5) attached_4 = self.attach_or_detach_to_vg(True) if attached_4: rospy.logwarn(\"1. Playing Pkg4 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen10_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle3 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle3 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen11\": # Picking Package 11 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_5 = 0 rospy.logwarn(\"1. Playing Home to Pkg5 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg5.yaml', 5) attached_5 = self.attach_or_detach_to_vg(True) if attached_5: rospy.logwarn(\"1. Playing Pkg5 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen11_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle4 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle4 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen12\": # Picking Package 12 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_6 = 0 rospy.logwarn(\"1. Playing Home to Pkg6 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg6.yaml', 5) attached_6 = self.attach_or_detach_to_vg(True) if attached_6: rospy.logwarn(\"1. Playing Pkg6 to Home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen12_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle5 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle5 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen30\": # Picking Package 30 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) rospy.logwarn(\"1. Playing Home to Pkg10 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg10.yaml', 5) attached_10 = 0 attached_10 = self.attach_or_detach_to_vg(True) if attached_10: rospy.logwarn(\"1. Playing Pkg10 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_to_cartesian_ALTERNATE.yaml', 5) rospy.logwarn(\"1. Playing Pkg10 cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen30_cartesian_to_home_ALTERNATE.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle6 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server self.action_client._goal_handles[self.i] = goal_handle6 # updating goal handle self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen31\": # Picking Package 31 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) rospy.logwarn(\"1. Playing Home to Pkg11 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg11.yaml', 5) attached_11 = 0 attached_11 = self.attach_or_detach_to_vg(True) if attached_11: rospy.logwarn(\"1. Playing Pkg11 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_to_cartesian_ALTERNATE.yaml', 5) rospy.logwarn(\"1. Playing Pkg11 cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen31_cartesian_to_home_ALTERNATE.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle7 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle7 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") if pkg_name == \"packagen32\": # Picking Package 32 from the shelf # self.hard_set_joint_angles(home_pos_list, 5) attached_12 = 0 rospy.logwarn(\"1. Playing Home to Pkg12 Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'home_to_pkg12.yaml', 5) attached_12 = self.attach_or_detach_to_vg(True) if attached_12: rospy.logwarn(\"1. Playing Pkg32 to cartesian Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_to_cartesian.yaml', 5) rospy.logwarn(\"1. Playing cartesian to home Trajectory File\") self.moveit_hard_play_planned_path_from_file(self._file_path, 'packagen32_cartesian_to_home.yaml', 5) self.attach_or_detach_to_vg(False) mesg = json.dumps(new_dict) goal_handle8 = self.action_client.send_goal(\"mqtt\", \"pub_dispatch\", self.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle self.action_client._goal_handles[self.i] = goal_handle8 self.i += 1 rospy.loginfo(\"Goal #\" + str(self.i-1) + \" Sent\") def main(): rospy.sleep(20) ur5 = Ur5Moveit(sys.argv[1]) ic = Camera1() lst_red = [] lst_green = [] lst_yellow = [] rospy.sleep(5) # Sort the detected packages into respective lists based on color dict_order_temp = ic.dictorder print \"PRINTING DICTORDER\", dict_order_temp for i in dict_order_temp.items(): if i[1] == \"red\": lst_red.append(i) print(\"PRINTING SEPERATELY\", lst_red) elif i[1] == \"yellow\": lst_yellow.append(i) elif i[1] == \"green\": lst_green.append(i) lst_red.sort(key=lambda x: x[0]) lst_yellow.sort(key=lambda x: x[0]) lst_green.sort(key=lambda x: x[0]) print \"PRINTING LISTS\", lst_red, lst_yellow, lst_green lst_red.pop(2) lst_yellow.pop(2) lst_green.pop(2) print \"POPPED LISTS\", lst_red, lst_yellow, lst_green ic.unsubscribe() # Define position above conveyor belt home_pos_list = [math.radians(7.838), math.radians(-139.943), math.radians(-58.278), math.radians(-71.819), math.radians(89.975), math.radians(7.833)] ur5.hard_set_joint_angles(home_pos_list, 5) # Used for traversing the list of dictionaries i = 0 while not rospy.is_shutdown(): if ur5.placed_order != []: while i < len(ur5.placed_order): if ur5.placed_order_red !=[]: print \"ENTERED RED IN MAIN\" var_flag = lst_red[0][0] ur5.func_packages(var_flag, ur5.placed_order_red[0]) ur5.placed_order_red.pop(0) lst_red.pop(0) i += 1 elif ur5.placed_order_yellow !=[]: var_flag = lst_yellow[0][0] ur5.func_packages(var_flag, ur5.placed_order_yellow[0]) ur5.placed_order_yellow.pop(0) lst_yellow.pop(0) i += 1 elif ur5.placed_order_green !=[]: var_flag = lst_green[0][0] print \"DETECTED GREEN\" ur5.func_packages(var_flag, ur5.placed_order_green[0]) ur5.placed_order_green.pop(0) lst_green.pop(0) i += 1 del ur5 if __name__ == '__main__': main() 2.node_t5_ur5_2.py Importing all the standard libraries This block imports all necessary header files required in the node. #! /usr/bin/env python import os import math import sys import copy import threading import json import time from time import gmtime, strftime from datetime import date, datetime, timedelta import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg import actionlib import rospkg import yaml import tf2_ros import tf2_msgs.msg from tf.transformations import euler_from_quaternion, quaternion_from_euler import numpy as np from std_msgs.msg import String from sensor_msgs.msg import Image from cv_bridge import CvBridge, CvBridgeError from pyzbar.pyzbar import decode from std_srvs.srv import Empty import requests # Message Class used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotGoal from pkg_ros_iot_bridge.msg import msgRosIotResult from pkg_ros_iot_bridge.msg import msgMqttSub from pkg_vb_sim.srv import vacuumGripper from pkg_vb_sim.srv import ConveyorBeltControl from pkg_vb_sim.srv import conveyorBeltPowerMsg from pkg_vb_sim.msg import LogicalCameraImage import cv2 This class is responsible for using the node as an action client This block saves all the values from parameter server onto variables to be used later. class IotRosBridgeActionClient: '''This class is responsible for using the node as an action client''' Constructor function # Constructor def __init__(self): # Initialize Action Client self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction) # Dictionary to Store all the goal handels self._goal_handles = {} # Store the MQTT Topic on which to Publish in a variable param_config_iot = rospy.get_param('config_iot') self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic'] # Wait for Action Server that will use # the action - '/action_iot_ros' to start self._ac.wait_for_server() rospy.loginfo(\"Action server up, we can send goals.\") This function will be called when there is a change of state in the Action Client State Machine def on_transition(self, goal_handle): '''This function will be called when there is a change of state in the Action Client State Machine''' # from on_goal() to on_transition(). goal_handle generated by # send_goal() is used here. result = msgRosIotResult() index = 0 for i in self._goal_handles: if self._goal_handles[i] == goal_handle: index = i break rospy.loginfo(\"Transition Callback. Client Goal Handle #: \" + str(index)) rospy.loginfo(\"Comm. State: \" + str(goal_handle.get_comm_state())) rospy.loginfo(\"Goal Status: \" + str(goal_handle.get_goal_status())) # Comm State - Monitors the State Machine of the Client # which is different from Server's # Comm State = 2 -> Active # Comm State = 3 -> Wating for Result # Comm State = 7 -> Done # if (Comm State == ACTIVE) if goal_handle.get_comm_state() == 2: rospy.loginfo(str(index) + \": Goal just went active.\") # if (Comm State == DONE) if goal_handle.get_comm_state() == 7: rospy.loginfo(str(index) + \": Goal is DONE\") rospy.loginfo(goal_handle.get_terminal_state()) # get_result() gets the result produced by the Action Server result = goal_handle.get_result() rospy.loginfo(result.flag_success) if result.flag_success: rospy.loginfo(\"Goal successfully completed. Client Goal Handle #: \" + str(index)) else: rospy.loginfo(\"Goal failed. Client Goal Handle #: \" + str(index)) This function is used to send Goals to Action Server -As and when the action client function is called it send the recieved goal to the action server, this function has 4 arguments, containing information which is to be sent via the message file. # This function is used to send Goals to Action Server def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message): '''This function is used to send Goals to Action Server''' # Create a Goal Message object goal = msgRosIotGoal() goal.protocol = arg_protocol goal.mode = arg_mode goal.topic = arg_topic goal.message = arg_message rospy.loginfo(\"Send goal.\") # self.on_transition - It is a function pointer to a # function which will be called when # there is a change of state in the Action Client State Machine goal_handle = self._ac.send_goal(goal, self.on_transition, None) return goal_handle This class performs image processing tasks class Camera1: '''This class performs image processing tasks''' Constructor of class Camera1 def __init__(self): '''Constructor of class Camera1''' self.bridge = CvBridge() self.image_sub = rospy.Subscriber(\"/eyrc/vb/camera_1/image_raw\", Image, self.callback) self.dictorder = {} Decodes the qr code This function gets the entire image as a set of data, this is passed to the decode() function, which returns a dictionary containing information regarding the positions and decoded color of the respective package. # Qr Code decode function def get_qr_data(self, arg_image): '''Decodes the qr code''' qr_result = decode(arg_image) len_lst = len(qr_result) color_dict = {} print \"LENGTH OF qr_result\", len_lst for i in range(len_lst): if (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen00\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen01\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen02\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen10\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen11\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen12\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen20\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen21\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen22\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen30\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen31\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen32\"] = qr_result[i].data # print(\"FINAL DICTIONAR LIST\", color_dict) return color_dict Unsubscriber function used to unsubscribe from topics # Function definition to unsubscribe from a topic def unsubscribe(self): '''Unsubscriber function used to unsubscribe from topics''' # use the saved subscriber object to unregister the subscriber self.image_sub.unregister() Callback function called everytime 2D Camera sends data The image id obtained as a stream of data, to this two image processing functions under cv packages is applied this will vary the light densities and denoise the stream of image. The parameters passed in the denoising function determine quality of the denoised image. This denoised image is sent as an argument to get_qr_data() which then performs detection. # Call back function definition def callback(self, data): '''Callback function called everytime 2D Camera sends data''' print \"CALLBACK ENTERED\" try: cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") except CvBridgeError as e: rospy.logerr(e) # (rows, cols, channels) = cv_image.shape contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0) dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, 20, 25, 7, 21) image = dst # Resize a 720x1280 image to 360x640 to fit it on the screen # resized_image = cv2.resize(image, (720/2, 1280/2)) # cv2.imshow(\"/eyrc/vb/camera_1/image_raw\", resized_image) self.dictorder = self.get_qr_data(image) print(\"PACKAGE ORDER\", self.dictorder) cv2.waitKey(1) Main class that initializes the robot arms, configures MoveIt and contains object of action client class class Ur5Moveit: '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class''' Constructor of class Ur5Moveit # Constructor def __init__(self, arg_robot_name): '''Constructor of class Ur5Moveit''' rospy.init_node('node_t5_ur5_2', anonymous=True) self._robot_ns = '/' + arg_robot_name self._planning_group = \"manipulator\" self._commander = moveit_commander.roscpp_initialize(sys.argv) self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns) self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1) self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction) self._exectute_trajectory_client.wait_for_server() self._planning_frame = self._group.get_planning_frame() self._eef_link = self._group.get_end_effector_link() self._group_names = self._robot.get_group_names() self._box_name = 'box' self.pkg_name = None self.pick_condition = 0 self.placed_order = {} self.package_order = {} self.lst_red = [] self.lst_green = [] self.lst_yellow = [] # Attribute to store computed trajectory by the planner self._computed_plan = '' # Current State of the Robot is needed to add box to planning scene self._curr_state = self._robot.get_current_state() rospy.loginfo( '\\033[94m' + \"Planning Group: {}\".format(self._planning_frame) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"End Effector Link: {}\".format(self._eef_link) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"Group Names: {}\".format(self._group_names) + '\\033[0m') rp = rospkg.RosPack() self._pkg_path = rp.get_path('pkg_task5') self._file_path = self._pkg_path + '/config/saved_trajectories/' rospy.loginfo(\"Package Path: {}\".format(self._file_path)) rospy.loginfo('\\033[94m' + \" >>> Ur5Moveit init done.\" + '\\033[0m') # DECLARING OBJECT OF ACTION CLASS HERE self.action_client = IotRosBridgeActionClient() # define variable for updating handle values self.i = 0 # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print param_config_iot rospy.Subscriber(\"/ros_iot_bridge/mqtt/sub\", msgMqttSub, self.local_mqtt_sub_callback) Callback function called everytime mqtt topic receives new orders. When there is an order passed to the local mqtt topic, this callback function is invoked. The message is decoded into a dictionary. Based on the key \"item\" of the dictionary, the recived orders are classified into seperate lists which will represent the color of the package, i.e Medicine ~ Red, Food ~ Yellow, Clothes ~Green. These lists are later used to sort into different bins based on the assigned color. def local_mqtt_sub_callback(self, msg): '''Callback function called everytime mqtt topic receives new orders''' payload = msg.message dict_payload = json.loads(payload) print \"PRINTING PAYLOAD FROM NEW NODE_T5_UR5_2\", dict_payload # self.placed_order = dict_payload if dict_payload[\"item\"] == \"Medicine\": self.lst_red.append(dict_payload) elif dict_payload[\"item\"] == \"Food\": self.lst_yellow.append(dict_payload) elif dict_payload[\"item\"] == \"Clothes\": self.lst_green.append(dict_payload) Clear Octomap def clear_octomap(self): clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + \"/clear_octomap\", Empty) return clear_octomap_service_proxy() Function to set joint angles of arm with choice number of attempts def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): '''Function to set joint angles of arm with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.set_joint_angles(arg_list_joint_angles) rospy.logwarn(\"attempts: {}\".format(number_attempts)) Function to set Joint angles of the arm def set_joint_angles(self, arg_list_joint_angles): '''Function to set Joint angles of the arm''' list_joint_values = self._group.get_current_joint_values() rospy.loginfo('\\033[94m' + \">>> Current Joint Values:\" + '\\033[0m') rospy.loginfo(list_joint_values) self._group.set_joint_value_target(arg_list_joint_angles) self._group.plan() flag_plan = self._group.go(wait=True) list_joint_values = self._group.get_current_joint_values() rospy.loginfo('\\033[94m' + \">>> Final Joint Values:\" + '\\033[0m') rospy.loginfo(list_joint_values) pose_values = self._group.get_current_pose().pose rospy.loginfo('\\033[94m' + \">>> Final Pose:\" + '\\033[0m') rospy.loginfo(pose_values) if flag_plan: rospy.loginfo( '\\033[94m' + \">>> set_joint_angles() Success\" + '\\033[0m') else: rospy.logerr( '\\033[94m' + \">>> set_joint_angles() Failed.\" + '\\033[0m') return flag_plan Plays pre recorded path def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): '''Plays pre recorded path''' file_path = arg_file_path + arg_file_name with open(file_path, 'r') as file_open: loaded_plan = yaml.load(file_open) ret = self._group.execute(loaded_plan) # rospy.logerr(ret) return ret Plays pre recorded paths with choice number of attempts def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): '''Plays pre recorded paths with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name) rospy.logwarn(\"attempts: {}\".format(number_attempts)) # # self.clear_octomap() return True Attaches/Detaches packages to vacuum gripper # Function definition to attach or detach package to vacuumGripper def attach_or_detach_to_vg(self, vg_flag=False): '''Attaches/Detaches packages to vacuum gripper''' rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2') try: grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2', vacuumGripper) grip1 = grip(vg_flag) return grip1.result except: print \"Service call failed for attach\" Starts and stops conveyor by calling the service # Function definition to start and stop conveyor def start_or_stop_conveyor(self, power=0): '''Starts and stops conveyor by calling the service''' rospy.wait_for_service('/eyrc/vb/conveyor/set_power') try: start = rospy.ServiceProxy('/eyrc/vb/conveyor/set_power', conveyorBeltPowerMsg) start1 = start(power) return start1.result except: print \"Service failed for conveyor\" Callback for logical camera 2 This callback is invoked when the logical camera detects any external packages below it (Other than the conveyor belt). The function recieves the information as an argument and stored in msg. If the list is not empty then check for the current position of the package, if it reaches directly below the camera this indicates the package is in the right position so that the arm can perform picking, The pick condition is enabled. Once the package goes out of range of the camera, the pick condition is disabled to allow picking of subsequent packages. # Call back function definition def sub_callback(self, msg): '''Callback for logical camera 2''' # If Red package is detcted self.pkg_lst = [\"packagen00\", \"packagen01\", \"packagen02\", \"packagen10\", \"packagen11\", \"packagen12\", \"packagen20\", \"packagen21\", \"packagen22\", \"packagen30\", \"packagen31\", \"packagen32\"] try: self.pkg_name = msg.models[-1].type if msg.models != []: yn = msg.models[-1].pose.position.y xn = msg.models[-1].pose.position.x if yn <= 0: # Check if package is below logical_camera_2 self.pick_condition = 1 else: self.pick_condition = 0 except: pass Deletes object of class # Destructor def __del__(self): '''Deletes object of class''' moveit_commander.roscpp_shutdown() rospy.loginfo( '\\033[94m' + \"Object of class Ur5Moveit Deleted.\" + '\\033[0m') Main function declaration A buffer time of 20 seconds is given so that the boxes are spawned properly. Classes are initialized and the conveyor is started. The subscriber for logical camera 2 is declared. After succesful detection of all 12 packages the topic from 2D Camera is unsubscribed. From the dictionary containing the detected packages via the 2D Camera, based on the key \"item\" of the dictionary parameters are extracted and encoded as a json string to send to action server as a goal. This repeated for all detected packages , hence the inventory sheet is updated. For the sorting action , pick condition is checked along with the color of the detected package under logical camera 2, based on both conditions the control flow is directed to appropriate block. Once placed into bins, goal as shipped is sent to the action server. The order which has finished processing is popped from the list previously defined. The same process is repetaed for other twp colors. def main(): rospy.sleep(20) ur5 = Ur5Moveit(sys.argv[1]) ur5.start_or_stop_conveyor(100) ic = Camera1() rospy.sleep(2) attach_flag_red = 0 attach_flag_green = 0 attach_flag_yellow = 0 rospy.Subscriber(\"/eyrc/vb/logical_camera_2\", LogicalCameraImage, ur5.sub_callback) rospy.sleep(5) ic.unsubscribe() for item in ic.dictorder.items(): if item[1] == \"red\": # defining our sheet name in the 'id' variable and the the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"R\" + str(item[0][-2:])+strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Medicine\", \"Priority\": \"HP\", \"Storage Number\": \"R\" + str(item[0][-2]) +\" C\"+str(item[0][-1]), \"Cost\": 450, \"Quantity\": 1} mesg = json.dumps(parameters) # sending message to bridge server goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) elif item[1] == \"yellow\": # defining our sheet name in the 'id' variable and # the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"Y\" + str(item[0][-2:]) + strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Food\", \"Priority\": \"MP\", \"Storage Number\": \"R\" + str(item[0][-2]) + \" C\"+str(item[0][-1]), \"Cost\": 250, \"Quantity\": 1} mesg = json.dumps(parameters) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) elif item[1] == \"green\": # defining our sheet name in the 'id' variable and the the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"G\" + str(item[0][-2:]) + strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Clothes\", \"Priority\": \"LP\", \"Storage Number\": \"R\" + str(item[0][-2]) + \" C\"+str(item[0][-1]), \"Cost\": 150, \"Quantity\": 1} mesg = json.dumps(parameters) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) box_length = 0.15 # Length of the Package vacuum_gripper_width = 0.115 # Vacuum Gripper Width delta = vacuum_gripper_width + (box_length/2) # 0.19 # Set, joints, angles definition for home position home_pos_list = [math.radians(7.838), math.radians(-139.943), math.radians(-58.278), math.radians(-71.819), math.radians(89.975), math.radians(7.833)] # Set, joints, angles definition for home position zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00)] ur5.hard_set_joint_angles(home_pos_list, 5) while not rospy.is_shutdown(): package_name = ur5.pkg_name try: # Condition check; if package detected is red if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"red\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_red = ur5.attach_or_detach_to_vg(True) if attach_flag_red: rospy.logwarn(\"1. Playing Home to Red bin Trajectory File\") # Path from home pose to bin ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_red_bin_ur5_2.yaml', 5) ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_red[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_red.pop(0) rospy.logwarn(\"2. Playing Red bin to Home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'red_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_red = 0 # Condition check; if package detected is green if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"green\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_green = ur5.attach_or_detach_to_vg(True) if attach_flag_green: rospy.logwarn(\"5. Playing Home to Green bin Trajectory File\") # Path from home pose to bin ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_green_bin_ur5_2.yaml', 5) ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_green[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_green.pop(0) rospy.logwarn(\"6. Playing Green Bin to Home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'green_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_green = 0 # Condition check; if package detected is yellow if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"yellow\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_yellow = ur5.attach_or_detach_to_vg(True) if attach_flag_yellow: rospy.logwarn(\"3. Playing Home to Yellow bin Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_yellow_bin_ur5_2.yaml', 5) # Path from home pose to bin ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_yellow[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_yellow.pop(0) rospy.logwarn(\"4. Playing Yellow bin to home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'yellow_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_yellow = 0 except: pass del ur5 Calling Main function if __name__ == '__main__': main() Complete code of node_t5_ur5_2.py #! /usr/bin/env python import os import math import sys import copy import threading import json import time from time import gmtime, strftime from datetime import date, datetime, timedelta import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg import actionlib import rospkg import yaml import tf2_ros import tf2_msgs.msg from tf.transformations import euler_from_quaternion, quaternion_from_euler import numpy as np from std_msgs.msg import String from sensor_msgs.msg import Image from cv_bridge import CvBridge, CvBridgeError from pyzbar.pyzbar import decode from std_srvs.srv import Empty import requests # Message Class used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotGoal from pkg_ros_iot_bridge.msg import msgRosIotResult from pkg_ros_iot_bridge.msg import msgMqttSub from pkg_vb_sim.srv import vacuumGripper from pkg_vb_sim.srv import ConveyorBeltControl from pkg_vb_sim.srv import conveyorBeltPowerMsg from pkg_vb_sim.msg import LogicalCameraImage import cv2 class IotRosBridgeActionClient: '''This class is responsible for using the node as an action client''' # Constructor def __init__(self): # Initialize Action Client self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction) # Dictionary to Store all the goal handels self._goal_handles = {} # Store the MQTT Topic on which to Publish in a variable param_config_iot = rospy.get_param('config_iot') self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_MQTT = param_config_iot['mqtt']['sub_cb_ros_topic'] # Wait for Action Server that will use # the action - '/action_iot_ros' to start self._ac.wait_for_server() rospy.loginfo(\"Action server up, we can send goals.\") def on_transition(self, goal_handle): '''This function will be called when there is a change of state in the Action Client State Machine''' # from on_goal() to on_transition(). goal_handle generated by # send_goal() is used here. result = msgRosIotResult() index = 0 for i in self._goal_handles: if self._goal_handles[i] == goal_handle: index = i break rospy.loginfo(\"Transition Callback. Client Goal Handle #: \" + str(index)) rospy.loginfo(\"Comm. State: \" + str(goal_handle.get_comm_state())) rospy.loginfo(\"Goal Status: \" + str(goal_handle.get_goal_status())) # Comm State - Monitors the State Machine of the Client # which is different from Server's # Comm State = 2 -> Active # Comm State = 3 -> Wating for Result # Comm State = 7 -> Done # if (Comm State == ACTIVE) if goal_handle.get_comm_state() == 2: rospy.loginfo(str(index) + \": Goal just went active.\") # if (Comm State == DONE) if goal_handle.get_comm_state() == 7: rospy.loginfo(str(index) + \": Goal is DONE\") rospy.loginfo(goal_handle.get_terminal_state()) # get_result() gets the result produced by the Action Server result = goal_handle.get_result() rospy.loginfo(result.flag_success) if result.flag_success: rospy.loginfo(\"Goal successfully completed. Client Goal Handle #: \" + str(index)) else: rospy.loginfo(\"Goal failed. Client Goal Handle #: \" + str(index)) # This function is used to send Goals to Action Server def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message): '''This function is used to send Goals to Action Server''' # Create a Goal Message object goal = msgRosIotGoal() goal.protocol = arg_protocol goal.mode = arg_mode goal.topic = arg_topic goal.message = arg_message rospy.loginfo(\"Send goal.\") # self.on_transition - It is a function pointer to a # function which will be called when # there is a change of state in the Action Client State Machine goal_handle = self._ac.send_goal(goal, self.on_transition, None) return goal_handle class Camera1: '''This class performs image processing tasks''' def __init__(self): '''Constructor of class Camera1''' self.bridge = CvBridge() self.image_sub = rospy.Subscriber(\"/eyrc/vb/camera_1/image_raw\", Image, self.callback) self.dictorder = {} # Qr Code decode function def get_qr_data(self, arg_image): '''Decodes the qr code''' qr_result = decode(arg_image) len_lst = len(qr_result) color_dict = {} print \"LENGTH OF qr_result\", len_lst for i in range(len_lst): if (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen00\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen01\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 290 and qr_result[i].rect[1] <= 340): color_dict[\"packagen02\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen10\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen11\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 480 and qr_result[i].rect[1] <= 520): color_dict[\"packagen12\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen20\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen21\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 630 and qr_result[i].rect[1] <= 660): color_dict[\"packagen22\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 110 and qr_result[i].rect[0] <= 150) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen30\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 300 and qr_result[i].rect[0] <= 330) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen31\"] = qr_result[i].data elif (qr_result[i].rect[0] >= 490 and qr_result[i].rect[0] <= 520) and (qr_result[i].rect[1] >= 780 and qr_result[i].rect[1] <= 810): color_dict[\"packagen32\"] = qr_result[i].data # print(\"FINAL DICTIONAR LIST\", color_dict) return color_dict # Function definition to unsubscribe from a topic def unsubscribe(self): '''Unsubscriber function used to unsubscribe from topics''' # use the saved subscriber object to unregister the subscriber self.image_sub.unregister() # Call back function definition def callback(self, data): '''Callback function called everytime 2D Camera sends data''' try: cv_image = self.bridge.imgmsg_to_cv2(data, \"bgr8\") except CvBridgeError as e: rospy.logerr(e) # (rows, cols, channels) = cv_image.shape contrast_img = cv2.addWeighted(cv_image, 2.5, np.zeros(cv_image.shape, cv_image.dtype), 0, 0) dst = cv2.fastNlMeansDenoisingColored(contrast_img, None, 20, 25, 7, 21) image = dst # Resize a 720x1280 image to 360x640 to fit it on the screen # resized_image = cv2.resize(image, (720/2, 1280/2)) # cv2.imshow(\"/eyrc/vb/camera_1/image_raw\", resized_image) self.dictorder = self.get_qr_data(image) print \"PACKAGE ORDER\", self.dictorder # rospy.loginfo(self.get_qr_data(image)) cv2.waitKey(1) class Ur5Moveit: '''Main class that initializes the robot arms, configures MoveIt and contains object of action client class''' # Constructor def __init__(self, arg_robot_name): '''Constructor of class Ur5Moveit''' rospy.init_node('node_t5_ur5_2', anonymous=True) self._robot_ns = '/' + arg_robot_name self._planning_group = \"manipulator\" self._commander = moveit_commander.roscpp_initialize(sys.argv) self._robot = moveit_commander.RobotCommander(robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._scene = moveit_commander.PlanningSceneInterface(ns=self._robot_ns) self._group = moveit_commander.MoveGroupCommander(self._planning_group, robot_description=self._robot_ns + \"/robot_description\", ns=self._robot_ns) self._display_trajectory_publisher = rospy.Publisher(self._robot_ns + '/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=1) self._exectute_trajectory_client = actionlib.SimpleActionClient(self._robot_ns + '/execute_trajectory', moveit_msgs.msg.ExecuteTrajectoryAction) self._exectute_trajectory_client.wait_for_server() self._planning_frame = self._group.get_planning_frame() self._eef_link = self._group.get_end_effector_link() self._group_names = self._robot.get_group_names() self._box_name = 'box' self.pkg_name = None self.pick_condition = 0 self.placed_order = {} self.package_order = {} self.lst_red = [] self.lst_green = [] self.lst_yellow = [] # Attribute to store computed trajectory by the planner self._computed_plan = '' # Current State of the Robot is needed to add box to planning scene self._curr_state = self._robot.get_current_state() rospy.loginfo( '\\033[94m' + \"Planning Group: {}\".format(self._planning_frame) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"End Effector Link: {}\".format(self._eef_link) + '\\033[0m') rospy.loginfo( '\\033[94m' + \"Group Names: {}\".format(self._group_names) + '\\033[0m') rp = rospkg.RosPack() self._pkg_path = rp.get_path('pkg_task5') self._file_path = self._pkg_path + '/config/saved_trajectories/' rospy.loginfo(\"Package Path: {}\".format(self._file_path)) rospy.loginfo('\\033[94m' + \" >>> Ur5Moveit init done.\" + '\\033[0m') # DECLARING OBJECT OF ACTION CLASS HERE self.action_client = IotRosBridgeActionClient() # define variable for updating handle values self.i = 0 # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print param_config_iot rospy.Subscriber(\"/ros_iot_bridge/mqtt/sub\", msgMqttSub, self.local_mqtt_sub_callback) def local_mqtt_sub_callback(self, msg): '''Callback function called everytime mqtt topic receives new orders''' payload = msg.message dict_payload = json.loads(payload) print \"PRINTING PAYLOAD FROM NEW NODE_T5_UR5_2\", dict_payload # self.placed_order = dict_payload if dict_payload[\"item\"] == \"Medicine\": self.lst_red.append(dict_payload) elif dict_payload[\"item\"] == \"Food\": self.lst_yellow.append(dict_payload) elif dict_payload[\"item\"] == \"Clothes\": self.lst_green.append(dict_payload) def clear_octomap(self): clear_octomap_service_proxy = rospy.ServiceProxy(self._robot_ns + \"/clear_octomap\", Empty) return clear_octomap_service_proxy() def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): '''Function to set joint angles of arm with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.set_joint_angles(arg_list_joint_angles) rospy.logwarn(\"attempts: {}\".format(number_attempts)) def set_joint_angles(self, arg_list_joint_angles): '''Function to set Joint angles of the arm''' list_joint_values = self._group.get_current_joint_values() rospy.loginfo('\\033[94m' + \">>> Current Joint Values:\" + '\\033[0m') rospy.loginfo(list_joint_values) self._group.set_joint_value_target(arg_list_joint_angles) self._group.plan() flag_plan = self._group.go(wait=True) list_joint_values = self._group.get_current_joint_values() rospy.loginfo('\\033[94m' + \">>> Final Joint Values:\" + '\\033[0m') rospy.loginfo(list_joint_values) pose_values = self._group.get_current_pose().pose rospy.loginfo('\\033[94m' + \">>> Final Pose:\" + '\\033[0m') rospy.loginfo(pose_values) if flag_plan: rospy.loginfo( '\\033[94m' + \">>> set_joint_angles() Success\" + '\\033[0m') else: rospy.logerr( '\\033[94m' + \">>> set_joint_angles() Failed.\" + '\\033[0m') return flag_plan def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): '''Plays pre recorded path''' file_path = arg_file_path + arg_file_name with open(file_path, 'r') as file_open: loaded_plan = yaml.load(file_open) ret = self._group.execute(loaded_plan) # rospy.logerr(ret) return ret def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): '''Plays pre recorded paths with choice number of attempts''' number_attempts = 0 flag_success = False while ((number_attempts <= arg_max_attempts) and (flag_success is False)): number_attempts += 1 flag_success = self.moveit_play_planned_path_from_file(arg_file_path, arg_file_name) rospy.logwarn(\"attempts: {}\".format(number_attempts)) # # self.clear_octomap() return True # Function definition to attach or detach package to vacuumGripper def attach_or_detach_to_vg(self, vg_flag=False): '''Attaches/Detaches packages to vacuum gripper''' rospy.wait_for_service('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2') try: grip = rospy.ServiceProxy('/eyrc/vb/ur5/activate_vacuum_gripper/ur5_2', vacuumGripper) grip1 = grip(vg_flag) return grip1.result except: print \"Service call failed for attach\" # Function definition to start and stop conveyor def start_or_stop_conveyor(self, power=0): '''Starts and stops conveyor by calling the service''' rospy.wait_for_service('/eyrc/vb/conveyor/set_power') try: start = rospy.ServiceProxy('/eyrc/vb/conveyor/set_power', conveyorBeltPowerMsg) start1 = start(power) return start1.result except: print \"Service failed for conveyor\" # Call back function definition def sub_callback(self, msg): '''Callback for logical camera 2''' # If Red package is detcted self.pkg_lst = [\"packagen00\", \"packagen01\", \"packagen02\", \"packagen10\", \"packagen11\", \"packagen12\", \"packagen20\", \"packagen21\", \"packagen22\", \"packagen30\", \"packagen31\", \"packagen32\"] try: self.pkg_name = msg.models[-1].type if msg.models != []: yn = msg.models[-1].pose.position.y xn = msg.models[-1].pose.position.x if yn <= 0: # Check if package is below logical_camera_2 self.pick_condition = 1 else: self.pick_condition = 0 except: pass # Destructor def __del__(self): '''Deletes object of class''' moveit_commander.roscpp_shutdown() rospy.loginfo( '\\033[94m' + \"Object of class Ur5Moveit Deleted.\" + '\\033[0m') def main(): rospy.sleep(20) ur5 = Ur5Moveit(sys.argv[1]) ur5.start_or_stop_conveyor(100) ic = Camera1() rospy.sleep(2) attach_flag_red = 0 attach_flag_green = 0 attach_flag_yellow = 0 rospy.Subscriber(\"/eyrc/vb/logical_camera_2\", LogicalCameraImage, ur5.sub_callback) rospy.sleep(5) ic.unsubscribe() for item in ic.dictorder.items(): if item[1] == \"red\": # defining our sheet name in the 'id' variable and the the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"R\" + str(item[0][-2:])+strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Medicine\", \"Priority\": \"HP\", \"Storage Number\": \"R\" + str(item[0][-2]) +\" C\"+str(item[0][-1]), \"Cost\": 450, \"Quantity\": 1} mesg = json.dumps(parameters) # sending message to bridge server goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) elif item[1] == \"yellow\": # defining our sheet name in the 'id' variable and # the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"Y\" + str(item[0][-2:]) + strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Food\", \"Priority\": \"MP\", \"Storage Number\": \"R\" + str(item[0][-2]) + \" C\"+str(item[0][-1]), \"Cost\": 250, \"Quantity\": 1} mesg = json.dumps(parameters) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) elif item[1] == \"green\": # defining our sheet name in the 'id' variable and the the column where we want to update the value parameters = {\"id\": \"Inventory\", \"Team Id\": \"VB#0302\", \"Unique Id\": \"JAADjaad\", \"SKU\": \"G\" + str(item[0][-2:]) + strftime(\"%m\", gmtime()) + strftime(\"%y\", gmtime()), \"Item\": \"Clothes\", \"Priority\": \"LP\", \"Storage Number\": \"R\" + str(item[0][-2]) + \" C\"+str(item[0][-1]), \"Cost\": 150, \"Quantity\": 1} mesg = json.dumps(parameters) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_inventory\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") rospy.sleep(1) box_length = 0.15 # Length of the Package vacuum_gripper_width = 0.115 # Vacuum Gripper Width delta = vacuum_gripper_width + (box_length/2) # 0.19 # Set, joints, angles definition for home position home_pos_list = [math.radians(7.838), math.radians(-139.943), math.radians(-58.278), math.radians(-71.819), math.radians(89.975), math.radians(7.833)] # Set, joints, angles definition for home position zero_list = [math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00), math.radians(0.00)] ur5.hard_set_joint_angles(home_pos_list, 5) while not rospy.is_shutdown(): package_name = ur5.pkg_name try: # Condition check; if package detected is red if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"red\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_red = ur5.attach_or_detach_to_vg(True) if attach_flag_red: rospy.logwarn(\"1. Playing Home to Red bin Trajectory File\") # Path from home pose to bin ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_red_bin_ur5_2.yaml', 5) ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_red[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_red.pop(0) rospy.logwarn(\"2. Playing Red bin to Home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'red_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_red = 0 # Condition check; if package detected is green if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"green\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_green = ur5.attach_or_detach_to_vg(True) if attach_flag_green: rospy.logwarn(\"5. Playing Home to Green bin Trajectory File\") # Path from home pose to bin ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_green_bin_ur5_2.yaml', 5) ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_green[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_green.pop(0) rospy.logwarn(\"6. Playing Green Bin to Home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'green_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_green = 0 # Condition check; if package detected is yellow if ur5.pick_condition == 1 and ic.dictorder[package_name] == \"yellow\": ur5.start_or_stop_conveyor(0) ur5.hard_set_joint_angles(home_pos_list, 5) # Attach package attach_flag_yellow = ur5.attach_or_detach_to_vg(True) if attach_flag_yellow: rospy.logwarn(\"3. Playing Home to Yellow bin Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'home_to_yellow_bin_ur5_2.yaml', 5) # Path from home pose to bin ur5.attach_or_detach_to_vg(False) ur5.start_or_stop_conveyor(100) mesg = json.dumps(ur5.lst_yellow[0]) goal_handle = ur5.action_client.send_goal(\"mqtt\", \"pub_ship\", ur5.action_client._config_mqtt_pub_topic, mesg) # sending message to bridge server # updating goal handle ur5.action_client._goal_handles[ur5.i] = goal_handle ur5.i += 1 rospy.loginfo(\"Goal #\" + str(ur5.i-1) + \" Sent\") ur5.lst_yellow.pop(0) rospy.logwarn(\"4. Playing Yellow bin to home Trajectory File\") ur5.moveit_hard_play_planned_path_from_file(ur5._file_path, 'yellow_bin_to_home_ur5_2.yaml', 5) # Path from bin to home pose attach_flag_yellow = 0 except: pass del ur5 if __name__ == '__main__': main() pkg_ros_iot_bridge 1) iot.py Importing all the necessary standard libraries from multiprocessing.dummy import Pool import time import requests import sys import paho.mqtt.client as mqtt #import the client1 from time import gmtime,strftime from datetime import date,datetime,timedelta import json import pytz IST = pytz.timezone('Asia/Kolkata') Clas definition class print_colour: Declaring Global Variables ''' Declaring Global Variables''' HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m' Function declaration for iot_callback # ----------------- MQTT SUB ------------------- def iot_func_callback_sub(client, userdata, message): '''Function declaration for iot_callback''' print(\"message received \" ,str(message.payload.decode(\"utf-8\"))) print(\"message topic=\",message.topic) print(\"message qos=\",message.qos) print(\"message retain flag=\",message.retain) Function declaration to create threads for simulatneous operation def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos): '''Function declaration to create threads for simulatneous operation''' try: mqtt_client = mqtt.Client() mqtt_client.on_message = arg_callback_func mqtt_client.connect(arg_broker_url, arg_broker_port) mqtt_client.subscribe(arg_mqtt_topic, arg_mqtt_qos) time.sleep(1) # wait # mqtt_client.loop_forever() # starts a blocking infinite loop mqtt_client.loop_start() # starts a new thread return 0 except: return -1 Function declaration to publish to mqtt client # ----------------- MQTT PUB ------------------- def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos): '''Function declaration to publish to mqtt client''' try: print(type(arg_mqtt_message)) mqtt_client = mqtt.Client(\"mqtt_pub\") mqtt_client.connect(arg_broker_url, arg_broker_port) mqtt_client.loop_start() #spred_sheet(arg_mqtt_message) #print(\"message was found\",arg_mqtt_message) print(\"Publishing message to topic\", arg_mqtt_message) mqtt_client.publish(arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos) time.sleep(0.1) # wait mqtt_client.loop_stop() #stop the loop return 0 except: return -1 Function declaration to publish to IncomingOrders Spredsheet Upon receiving data from the action client, the action server calls on this function to implement the updating incoming order spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated. # ---------------- SPREADSHEET UPDATION ------------------ def spred_sheet(var): '''Function declaration to publish to IncomingOrders Spredsheet''' print(\"DICTIONARY FROM iot.py:\", var) if(var['item'] == 'Food'): priority = 'MP' cost = 250 elif(var['item'] == 'Medicine'): priority = 'HP' cost = 450 elif(var['item'] == 'Clothes'): priority = 'LP' cost = 150 parameters1 = {\"id\":\"IncomingOrders\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":var['order_id'], \"Order Date and Time\":var['order_time'], \"Item\":var['item'], \"Priority\":priority, \"OrderQuantity\":var['qty'], \"City\":var['city'], \"Longitude\":var['lon'], \"Latitude\":var['lat'], \"Cost\":cost } parameters2 = {\"id\":\"IncomingOrders\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":var['order_id'], \"Order Date and Time\":var['order_time'], \"Item\":var['item'], \"Priority\":priority, \"OrderQuantity\":var['qty'], \"City\":var['city'], \"Longitude\":var['lon'], \"Latitude\":var['lat'], \"Cost\":cost } URL1 = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" # Google Apps Script URL URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # Google Apps Script URL response_1 = requests.get(URL1, params=parameters1) response_2 = requests.get(URL2, params=parameters2) print(response_1.content) # Update the parameters to sheet print(response_2.content) # Update the parameters to e_yantra sheet Function declaration to publish to OrdersDispatched Spredsheet Upon receiving data from the action client, the action server calls on this function to implement the updating Orders_dispatched spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated. def orders_dispatched(msg): '''Function declaration to publish to OrdersDispatched Spredsheet''' new_dict = json.loads(msg) if(new_dict['item'] == 'Food'): priority = 'MP' cost = 250 elif(new_dict['item'] == 'Medicine'): priority = 'HP' cost = 450 elif(new_dict['item'] == 'Clothes'): priority = 'LP' cost = 150 date_time = datetime.now(IST) parameters1 = {\"id\":\"OrdersDispatched\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict['order_id'], \"City\":new_dict['city'], \"Item\":new_dict['item'],\"Priority\":priority, \"Cost\":cost, \"Dispatch Status\":\"YES\", \"Dispatch Quantity\":new_dict['qty'], \"Dispatch Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\")} parameters2 = {\"id\":\"OrdersDispatched\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict['order_id'], \"City\":new_dict['city'], \"Item\":new_dict['item'],\"Priority\":priority, \"Cost\":cost, \"Dispatch Status\":\"YES\", \"Dispatch Quantity\":new_dict['qty'], \"Dispatch Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\")} URL1 = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" # Google Apps Script URL URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # E-yantra Google Apps Script URL response_1 = requests.get(URL1, params=parameters1) response_2 = requests.get(URL2, params=parameters2) print(response_1.content) # Update the parameters to sheet print(response_2.content) # Update the parameters to e_yantra sheet if(response_1.content == \"success\"): return 0 else: return -1 Function declaration to publish to Inventory Spredsheet Upon receiving data from the action client, the action server calls on this function to implement the updating inventory spreadsheet task. The Priority and cost are set based on the type of order recieved, the spreadsheet is updated. def inventory(msg): '''Function declaration to publish to Inventory Spredsheet''' new_dict = json.loads(msg) parameters = {\"id\":\"Inventory\", \"Team Id\":\"VB#0302\" , \"Unique Id\":\"JAADjaad\", \"SKU\":new_dict[\"SKU\"], \"Item\":new_dict[\"Item\"], \"Priority\":new_dict[\"Priority\"], \"Storage Number\":new_dict[\"Storage Number\"], \"Cost\":new_dict[\"Cost\"], \"Quantity\":new_dict[\"Quantity\"]} parameters2 = {\"id\":\"Inventory\", \"Team Id\":\"VB#0302\" , \"Unique Id\":\"JAADjaad\", \"SKU\":new_dict[\"SKU\"], \"Item\":new_dict[\"Item\"], \"Priority\":new_dict[\"Priority\"], \"Storage Number\":new_dict[\"Storage Number\"], \"Cost\":new_dict[\"Cost\"], \"Quantity\":new_dict[\"Quantity\"]} URL = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # E-yantra Google Apps Script URL response = requests.get(URL, params=parameters) response_2 = requests.get(URL2, params=parameters2) print(response.content) print(response_2.content) if(response.content == \"success\"): return 0 else: return -1 Function declaration to publish to OrdersShipped Spredsheet Upon receiving data from the action client, the action server calls on this function to implement the updating Orders_shipped spreadsheet task. The Priority,cost and time delay are set based on the type of order recieved, the spreadsheet is updated. def orders_shipped(msg): '''Function declaration to publish to OrdersShipped Spredsheet''' new_dict = json.loads(msg) if(new_dict['item'] == 'Food'): priority = 'MP' cost = 250 t = 3 elif(new_dict['item'] == 'Medicine'): priority = 'HP' cost = 450 t = 1 elif(new_dict['item'] == 'Clothes'): priority = 'LP' cost = 150 t = 5 date_time = datetime.now(IST) parameters = {\"id\":\"OrdersShipped\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict[\"order_id\"], \"City\":new_dict[\"city\"], \"Item\":new_dict[\"item\"], \"Priority\":priority, \"Shipped Quantity\":new_dict[\"qty\"], \"Cost\":cost, \"Shipped Status\":\"YES\", \"Shipped Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\"), \"Estimated Time of Delivery\":date.today() + timedelta(t)} parameters2 = {\"id\":\"OrdersShipped\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict[\"order_id\"], \"City\":new_dict[\"city\"], \"Item\":new_dict[\"item\"], \"Priority\":priority, \"Shipped Quantity\":new_dict[\"qty\"], \"Cost\":cost, \"Shipped Status\":\"YES\", \"Shipped Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\"), \"Estimated Time of Delivery\":date.today() + timedelta(t)} URL = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" response = requests.get(URL, params=parameters) response_2 = requests.get(URL2, params=parameters2) print(response.content) print(response_2.content) if(response.content == \"success\"): return 0 else: return -1 Complete code of iot.py from multiprocessing.dummy import Pool import time import requests import sys import paho.mqtt.client as mqtt #import the client1 from time import gmtime,strftime from datetime import date,datetime,timedelta import json import pytz IST = pytz.timezone('Asia/Kolkata') class print_colour: ''' Declaring Global Variables''' HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m' # ----------------- MQTT SUB ------------------- def iot_func_callback_sub(client, userdata, message): '''Function declaration for iot_callback''' print(\"message received \" ,str(message.payload.decode(\"utf-8\"))) print(\"message topic=\",message.topic) print(\"message qos=\",message.qos) print(\"message retain flag=\",message.retain) def mqtt_subscribe_thread_start(arg_callback_func, arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_qos): '''Function declaration to create threads for simulatneous operation''' try: mqtt_client = mqtt.Client() mqtt_client.on_message = arg_callback_func mqtt_client.connect(arg_broker_url, arg_broker_port) mqtt_client.subscribe(arg_mqtt_topic, arg_mqtt_qos) time.sleep(1) # wait # mqtt_client.loop_forever() # starts a blocking infinite loop mqtt_client.loop_start() # starts a new thread return 0 except: return -1 # ----------------- MQTT PUB ------------------- def mqtt_publish(arg_broker_url, arg_broker_port, arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos): '''Function declaration to publish to mqtt client''' try: print(type(arg_mqtt_message)) mqtt_client = mqtt.Client(\"mqtt_pub\") mqtt_client.connect(arg_broker_url, arg_broker_port) mqtt_client.loop_start() #spred_sheet(arg_mqtt_message) #print(\"message was found\",arg_mqtt_message) print(\"Publishing message to topic\", arg_mqtt_message) mqtt_client.publish(arg_mqtt_topic, arg_mqtt_message, arg_mqtt_qos) time.sleep(0.1) # wait mqtt_client.loop_stop() #stop the loop return 0 except: return -1 # ---------------- SPREADSHEET UPDATION ------------------ def spred_sheet(var): '''Function declaration to publish to IncomingOrders Spredsheet''' print(\"DICTIONARY FROM iot.py:\", var) if(var['item'] == 'Food'): priority = 'MP' cost = 250 elif(var['item'] == 'Medicine'): priority = 'HP' cost = 450 elif(var['item'] == 'Clothes'): priority = 'LP' cost = 150 parameters1 = {\"id\":\"IncomingOrders\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":var['order_id'], \"Order Date and Time\":var['order_time'], \"Item\":var['item'], \"Priority\":priority, \"OrderQuantity\":var['qty'], \"City\":var['city'], \"Longitude\":var['lon'], \"Latitude\":var['lat'], \"Cost\":cost } parameters2 = {\"id\":\"IncomingOrders\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":var['order_id'], \"Order Date and Time\":var['order_time'], \"Item\":var['item'], \"Priority\":priority, \"OrderQuantity\":var['qty'], \"City\":var['city'], \"Longitude\":var['lon'], \"Latitude\":var['lat'], \"Cost\":cost } URL1 = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" # Google Apps Script URL URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # Google Apps Script URL response_1 = requests.get(URL1, params=parameters1) response_2 = requests.get(URL2, params=parameters2) print(response_1.content) # Update the parameters to sheet print(response_2.content) # Update the parameters to e_yantra sheet def orders_dispatched(msg): '''Function declaration to publish to OrdersDispatched Spredsheet''' new_dict = json.loads(msg) if(new_dict['item'] == 'Food'): priority = 'MP' cost = 250 elif(new_dict['item'] == 'Medicine'): priority = 'HP' cost = 450 elif(new_dict['item'] == 'Clothes'): priority = 'LP' cost = 150 date_time = datetime.now(IST) parameters1 = {\"id\":\"OrdersDispatched\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict['order_id'], \"City\":new_dict['city'], \"Item\":new_dict['item'],\"Priority\":priority, \"Cost\":cost, \"Dispatch Status\":\"YES\", \"Dispatch Quantity\":new_dict['qty'], \"Dispatch Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\")} parameters2 = {\"id\":\"OrdersDispatched\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict['order_id'], \"City\":new_dict['city'], \"Item\":new_dict['item'],\"Priority\":priority, \"Cost\":cost, \"Dispatch Status\":\"YES\", \"Dispatch Quantity\":new_dict['qty'], \"Dispatch Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\")} URL1 = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" # Google Apps Script URL URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # E-yantra Google Apps Script URL response_1 = requests.get(URL1, params=parameters1) response_2 = requests.get(URL2, params=parameters2) print(response_1.content) # Update the parameters to sheet print(response_2.content) # Update the parameters to e_yantra sheet if(response_1.content == \"success\"): return 0 else: return -1 def inventory(msg): '''Function declaration to publish to Inventory Spredsheet''' new_dict = json.loads(msg) parameters = {\"id\":\"Inventory\", \"Team Id\":\"VB#0302\" , \"Unique Id\":\"JAADjaad\", \"SKU\":new_dict[\"SKU\"], \"Item\":new_dict[\"Item\"], \"Priority\":new_dict[\"Priority\"], \"Storage Number\":new_dict[\"Storage Number\"], \"Cost\":new_dict[\"Cost\"], \"Quantity\":new_dict[\"Quantity\"]} parameters2 = {\"id\":\"Inventory\", \"Team Id\":\"VB#0302\" , \"Unique Id\":\"JAADjaad\", \"SKU\":new_dict[\"SKU\"], \"Item\":new_dict[\"Item\"], \"Priority\":new_dict[\"Priority\"], \"Storage Number\":new_dict[\"Storage Number\"], \"Cost\":new_dict[\"Cost\"], \"Quantity\":new_dict[\"Quantity\"]} URL = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" # E-yantra Google Apps Script URL response = requests.get(URL, params=parameters) response_2 = requests.get(URL2, params=parameters2) print(response.content) print(response_2.content) if(response.content == \"success\"): return 0 else: return -1 def orders_shipped(msg): '''Function declaration to publish to OrdersShipped Spredsheet''' new_dict = json.loads(msg) if(new_dict['item'] == 'Food'): priority = 'MP' cost = 250 t = 3 elif(new_dict['item'] == 'Medicine'): priority = 'HP' cost = 450 t = 1 elif(new_dict['item'] == 'Clothes'): priority = 'LP' cost = 150 t = 5 date_time = datetime.now(IST) parameters = {\"id\":\"OrdersShipped\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict[\"order_id\"], \"City\":new_dict[\"city\"], \"Item\":new_dict[\"item\"], \"Priority\":priority, \"Shipped Quantity\":new_dict[\"qty\"], \"Cost\":cost, \"Shipped Status\":\"YES\", \"Shipped Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\"), \"Estimated Time of Delivery\":date.today() + timedelta(t)} parameters2 = {\"id\":\"OrdersShipped\", \"Team Id\":\"VB#0302\", \"Unique Id\":\"JAADjaad\", \"Order ID\":new_dict[\"order_id\"], \"City\":new_dict[\"city\"], \"Item\":new_dict[\"item\"], \"Priority\":priority, \"Shipped Quantity\":new_dict[\"qty\"], \"Cost\":cost, \"Shipped Status\":\"YES\", \"Shipped Date and Time\":date_time.strftime(\"%Y-%m-%d %H:%M:%S\"), \"Estimated Time of Delivery\":date.today() + timedelta(t)} URL = \"https://script.google.com/macros/s/AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" URL2 = \"https://script.google.com/macros/s/AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7/exec\" response = requests.get(URL, params=parameters) response_2 = requests.get(URL2, params=parameters2) print(response.content) print(response_2.content) if(response.content == \"success\"): return 0 else: return -1 2)node_action_server_ros_iot_bridge.py Importing all the standard libraries #!/usr/bin/env python # ROS Node - Action Server - ROS IoT Bridge import rospy import actionlib import threading import json from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class that is used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotGoal # Message Class that is used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotResult # Message Class that is used for Result Messages from pkg_ros_iot_bridge.msg import msgRosIotFeedback # Message Class that is used for Feedback Messages from pkg_ros_iot_bridge.msg import msgMqttSub # Message Class for MQTT Subscription Messages from pyiot import iot # Custom Python Module to perfrom MQTT Tasks This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics class RosIotBridgeActionServer: '''This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics''' Constructor function definition for RosIotBridgeActionServer # Constructor def __init__(self): '''Constructor function definition for RosIotBridgeActionServer''' # Initialize the Action Server self._as = actionlib.ActionServer('/action_ros_iot', msgRosIotAction, self.on_goal, self.on_cancel, auto_start=False) ''' * self.on_goal - It is the fuction pointer which points to a function which will be called when the Action Server receives a Goal. * self.on_cancel - It is the fuction pointer which points to a function which will be called when the Action Server receives a Cancel Request. ''' # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print(param_config_iot) # Initialize ROS Topic Publication # Incoming message from MQTT Subscription will be published on a ROS Topic (/ros_iot_bridge/mqtt/sub). # ROS Nodes can subscribe to this ROS Topic (/ros_iot_bridge/mqtt/sub) to get messages from MQTT Subscription. self._handle_ros_pub = rospy.Publisher(self._config_mqtt_sub_cb_ros_topic, msgMqttSub, queue_size=10) # Subscribe to MQTT Topic (eyrc/xYzqLm/iot_to_ros) which is defined in 'config_iot_ros.yaml'. # self.mqtt_sub_callback() function will be called when there is a message from MQTT Subscription. ret = iot.mqtt_subscribe_thread_start( self.mqtt_sub_callback, self._config_mqtt_server_url, self._config_mqtt_server_port, self._config_mqtt_getting_orders, self._config_mqtt_qos ) if(ret == 0): rospy.loginfo(\"MQTT Subscribe Thread Started\") else: rospy.logerr(\"Failed to start MQTT Subscribe Thread\") # Start the Action Server self._as.start() rospy.loginfo(\"Started ROS-IoT Bridge Action Server.\") This is a callback function for MQTT Subscriptions Upon reception of order from the internet this function publishes the same on the local topic so that the ros nodes can access the orders. This function also calls the function defined in iot,py to update the incoming orders spreadsheet. def mqtt_sub_callback(self, client, userdata, message): '''This is a callback function for MQTT Subscriptions''' payload = str(message.payload.decode(\"utf-8\")) print(\"[MQTT SUB CB] Message: \", payload) print(\"[MQTT SUB CB] Topic: \", message.topic) dict_payload = json.loads(payload) iot.spred_sheet(dict_payload) msg_mqtt_sub = msgMqttSub() msg_mqtt_sub.timestamp = rospy.Time.now() msg_mqtt_sub.topic = message.topic msg_mqtt_sub.message = payload self._handle_ros_pub.publish(msg_mqtt_sub) This function will be called when Action Server receives a Goal Upon reception of a goal from the action clients, this function starts threading so that multiple goals can be processed simultaneously, the current goal is passed onto the process goal function. def on_goal(self, goal_handle): '''This function will be called when Action Server receives a Goal''' goal = goal_handle.get_goal() rospy.loginfo(\"Received new goal from Client\") rospy.loginfo(goal) rospy.loginfo(goal.message) print(type(goal.message)) # Validate incoming goal parameters if(goal.protocol == \"mqtt\"): if((goal.mode == \"pub_dispatch\") or (goal.mode == \"sub\") or (goal.mode == \"pub_ship\") or (goal.mode == \"pub_inventory\")): goal_handle.set_accepted() # Start a new thread to process new goal from the client (For Asynchronous Processing of Goals) # 'self.process_goal' - is the function pointer which points to a function that will process incoming Goals thread = threading.Thread( name=\"worker\", target=self.process_goal, args=(goal_handle,) ) thread.start() else: goal_handle.set_rejected() return else: goal_handle.set_rejected() return This function is called is a separate thread to process Goal Upon reception of goal from on_goal, the function checks for the goal's mode parameter, this parameter is pre determined by the action client, and is set based on the requirement (dispatch, shipped, or inventory) based on the mode paramter appropriate functions from iot.py are called. def process_goal(self, goal_handle): '''Function to process the goal recieved from the action server''' flag_success = False result = msgRosIotResult() goal_id = goal_handle.get_goal_id() rospy.loginfo(\"Processing goal : \" + str(goal_id.id)) goal = goal_handle.get_goal() rospy.loginfo(goal) # Goal Processing if(goal.protocol == \"mqtt\"): rospy.logwarn(\"MQTT\") if(goal.mode == \"pub_dispatch\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) # ret = iot.mqtt_publish( self._config_mqtt_server_url, # self._config_mqtt_server_port, # goal.topic, # goal.message, # self._config_mqtt_qos ) # if(ret == 0): # rospy.loginfo(\"MQTT Publish Successful.\") # result.flag_success = True # else: # rospy.logerr(\"MQTT Failed to Publish\") # result.flag_success = False rospy.loginfo(\"Publishing to dispatched spread sheet\") ret = iot.orders_dispatched(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to dispatched Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to dispatched Spreadsheet!\") result.flag_success = False elif(goal.mode == \"pub_inventory\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) rospy.loginfo(\"Publishing to inventory spread sheet\") ret = iot.inventory(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to inventory Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to inventory Spreadsheet!\") result.flag_success = False elif(goal.mode == \"pub_ship\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) rospy.loginfo(\"Publishing to shipped spread sheet\") ret = iot.orders_shipped(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to shipped Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to shipped Spreadsheet!\") result.flag_success = False elif(goal.mode == \"sub\"): rospy.logwarn(\"MQTT SUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic) ret = iot.mqtt_subscribe_thread_start( self.mqtt_sub_callback, self._config_mqtt_server_url, self._config_mqtt_server_port, goal.topic, self._config_mqtt_qos ) if(ret == 0): rospy.loginfo(\"MQTT Subscribe Thread Started\") result.flag_success = True else: rospy.logerr(\"Failed to start MQTT Subscribe Thread\") result.flag_success = False rospy.loginfo(\"Send goal result to client\") if (result.flag_success == True): rospy.loginfo(\"Succeeded\") goal_handle.set_succeeded(result) else: rospy.loginfo(\"Goal Failed. Aborting.\") goal_handle.set_aborted(result) rospy.loginfo(\"Goal ID: \" + str(goal_id.id) + \" Goal Processing Done.\") This function will be called when Goal Cancel request is send to the Action Server def on_cancel(self, goal_handle): '''Function which cancels the goal if required ''' rospy.loginfo(\"Received cancel request.\") goal_id = goal_handle.get_goal_id() Main function definition def main(): '''Main function definition''' rospy.init_node('node_iot_ros_bridge_action_server') action_server = RosIotBridgeActionServer() rospy.spin() Calling Main function if __name__ == '__main__': '''Calling Main function''' main() Complete code of node_action_server_ros_iot_bridge.py #!/usr/bin/env python # ROS Node - Action Server - ROS IoT Bridge import rospy import actionlib import threading import json from pkg_ros_iot_bridge.msg import msgRosIotAction # Message Class that is used by ROS Actions internally from pkg_ros_iot_bridge.msg import msgRosIotGoal # Message Class that is used for Goal Messages from pkg_ros_iot_bridge.msg import msgRosIotResult # Message Class that is used for Result Messages from pkg_ros_iot_bridge.msg import msgRosIotFeedback # Message Class that is used for Feedback Messages from pkg_ros_iot_bridge.msg import msgMqttSub # Message Class for MQTT Subscription Messages from pyiot import iot # Custom Python Module to perfrom MQTT Tasks class RosIotBridgeActionServer: '''This class acts as a server bridging between the internet and the local Ros nodes using appropriate topics''' # Constructor def __init__(self): '''Constructor function definition for RosIotBridgeActionServer''' # Initialize the Action Server self._as = actionlib.ActionServer('/action_ros_iot', msgRosIotAction, self.on_goal, self.on_cancel, auto_start=False) ''' * self.on_goal - It is the fuction pointer which points to a function which will be called when the Action Server receives a Goal. * self.on_cancel - It is the fuction pointer which points to a function which will be called when the Action Server receives a Cancel Request. ''' # Read and Store IoT Configuration data from Parameter Server param_config_iot = rospy.get_param('config_iot') self._config_mqtt_server_url = param_config_iot['mqtt']['server_url'] self._config_mqtt_server_port = param_config_iot['mqtt']['server_port'] self._config_mqtt_sub_topic = param_config_iot['mqtt']['topic_sub'] self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub'] self._config_mqtt_qos = param_config_iot['mqtt']['qos'] self._config_mqtt_getting_orders = param_config_iot['mqtt']['getting_orders_topic'] self._config_mqtt_sub_cb_ros_topic = param_config_iot['mqtt']['sub_cb_ros_topic'] print(param_config_iot) # Initialize ROS Topic Publication # Incoming message from MQTT Subscription will be published on a ROS Topic (/ros_iot_bridge/mqtt/sub). # ROS Nodes can subscribe to this ROS Topic (/ros_iot_bridge/mqtt/sub) to get messages from MQTT Subscription. self._handle_ros_pub = rospy.Publisher(self._config_mqtt_sub_cb_ros_topic, msgMqttSub, queue_size=10) # Subscribe to MQTT Topic (eyrc/xYzqLm/iot_to_ros) which is defined in 'config_iot_ros.yaml'. # self.mqtt_sub_callback() function will be called when there is a message from MQTT Subscription. ret = iot.mqtt_subscribe_thread_start( self.mqtt_sub_callback, self._config_mqtt_server_url, self._config_mqtt_server_port, self._config_mqtt_getting_orders, self._config_mqtt_qos ) if(ret == 0): rospy.loginfo(\"MQTT Subscribe Thread Started\") else: rospy.logerr(\"Failed to start MQTT Subscribe Thread\") # Start the Action Server self._as.start() rospy.loginfo(\"Started ROS-IoT Bridge Action Server.\") def mqtt_sub_callback(self, client, userdata, message): '''This is a callback function for MQTT Subscriptions''' payload = str(message.payload.decode(\"utf-8\")) print(\"[MQTT SUB CB] Message: \", payload) print(\"[MQTT SUB CB] Topic: \", message.topic) dict_payload = json.loads(payload) iot.spred_sheet(dict_payload) msg_mqtt_sub = msgMqttSub() msg_mqtt_sub.timestamp = rospy.Time.now() msg_mqtt_sub.topic = message.topic msg_mqtt_sub.message = payload self._handle_ros_pub.publish(msg_mqtt_sub) def on_goal(self, goal_handle): '''This function will be called when Action Server receives a Goal''' goal = goal_handle.get_goal() rospy.loginfo(\"Received new goal from Client\") rospy.loginfo(goal) rospy.loginfo(goal.message) print(type(goal.message)) # Validate incoming goal parameters if(goal.protocol == \"mqtt\"): if((goal.mode == \"pub_dispatch\") or (goal.mode == \"sub\") or (goal.mode == \"pub_ship\") or (goal.mode == \"pub_inventory\")): goal_handle.set_accepted() # Start a new thread to process new goal from the client (For Asynchronous Processing of Goals) # 'self.process_goal' - is the function pointer which points to a function that will process incoming Goals thread = threading.Thread( name=\"worker\", target=self.process_goal, args=(goal_handle,) ) thread.start() else: goal_handle.set_rejected() return else: goal_handle.set_rejected() return def process_goal(self, goal_handle): '''Function to process the goal recieved from the action server''' flag_success = False result = msgRosIotResult() goal_id = goal_handle.get_goal_id() rospy.loginfo(\"Processing goal : \" + str(goal_id.id)) goal = goal_handle.get_goal() rospy.loginfo(goal) # Goal Processing if(goal.protocol == \"mqtt\"): rospy.logwarn(\"MQTT\") if(goal.mode == \"pub_dispatch\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) # ret = iot.mqtt_publish( self._config_mqtt_server_url, # self._config_mqtt_server_port, # goal.topic, # goal.message, # self._config_mqtt_qos ) # if(ret == 0): # rospy.loginfo(\"MQTT Publish Successful.\") # result.flag_success = True # else: # rospy.logerr(\"MQTT Failed to Publish\") # result.flag_success = False rospy.loginfo(\"Publishing to dispatched spread sheet\") ret = iot.orders_dispatched(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to dispatched Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to dispatched Spreadsheet!\") result.flag_success = False elif(goal.mode == \"pub_inventory\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) rospy.loginfo(\"Publishing to inventory spread sheet\") ret = iot.inventory(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to inventory Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to inventory Spreadsheet!\") result.flag_success = False elif(goal.mode == \"pub_ship\"): rospy.logwarn(\"MQTT PUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic + \" > \" + goal.message) rospy.loginfo(\"Publishing to shipped spread sheet\") ret = iot.orders_shipped(goal.message) # Invoking Spreadsheet update function written in file iot.py if(ret == 0): rospy.loginfo(\"Successfully published to shipped Spreadsheet!\") result.flag_success = True else: rospy.logerr(\"Failed to publish to shipped Spreadsheet!\") result.flag_success = False elif(goal.mode == \"sub\"): rospy.logwarn(\"MQTT SUB Goal ID: \" + str(goal_id.id)) rospy.logwarn(goal.topic) ret = iot.mqtt_subscribe_thread_start( self.mqtt_sub_callback, self._config_mqtt_server_url, self._config_mqtt_server_port, goal.topic, self._config_mqtt_qos ) if(ret == 0): rospy.loginfo(\"MQTT Subscribe Thread Started\") result.flag_success = True else: rospy.logerr(\"Failed to start MQTT Subscribe Thread\") result.flag_success = False rospy.loginfo(\"Send goal result to client\") if (result.flag_success == True): rospy.loginfo(\"Succeeded\") goal_handle.set_succeeded(result) else: rospy.loginfo(\"Goal Failed. Aborting.\") goal_handle.set_aborted(result) rospy.loginfo(\"Goal ID: \" + str(goal_id.id) + \" Goal Processing Done.\") def on_cancel(self, goal_handle): '''This function will be called when Goal Cancel request is send to the Action Server''' rospy.loginfo(\"Received cancel request.\") goal_id = goal_handle.get_goal_id() def main(): '''Main function definition''' rospy.init_node('node_iot_ros_bridge_action_server') action_server = RosIotBridgeActionServer() rospy.spin() if __name__ == '__main__': '''Calling Main function''' main() 3)config_pyiot.yaml config_pyiot.yaml contains all the parameters required to be accessed by all the nodes since it is published to parameter server. # config_iot_ros.yaml # IoT Configuration config_iot: mqtt: server_url: \"broker.mqttdashboard.com\" # http://www.hivemq.com/demos/websocket-client/ # server_url: \"test.mosquitto.org\" # Alternative to HiveMQ server_port: 1883 topic_sub: \"eyrc/JAADjaad/iot_to_ros\" # <unique_id> = xYzqLm topic_pub: \"eyrc/JAADjaad/ros_to_iot\" # <unique_id> = xYzqLm qos: 0 getting_orders_topic: \"/eyrc/vb/JAADjaad/orders\" sub_cb_ros_topic: \"/ros_iot_bridge/mqtt/sub\" # ROS nodes can listen to this topic to receive data from MQTT google_apps: spread_sheet_id: \"AKfycbyPFvLU1PlWDn_tVeEcwjUY1Z-x4MiylODiRP1Y465h2iCMuwc/exec\" e_yantra spread_sheet_id: \"AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7\"","title":"API Documentation"},{"location":"api_documentation/#api-documentation","text":"","title":"API DOCUMENTATION"},{"location":"api_documentation/#pkg_task5","text":"","title":"pkg_task5"},{"location":"api_documentation/#1node_t5py","text":"","title":"1.node_t5.py"},{"location":"api_documentation/#2node_t5_ur5_2py","text":"","title":"2.node_t5_ur5_2.py"},{"location":"api_documentation/#pkg_ros_iot_bridge","text":"","title":"pkg_ros_iot_bridge"},{"location":"api_documentation/#1-iotpy","text":"","title":"1) iot.py"},{"location":"api_documentation/#2node_action_server_ros_iot_bridgepy","text":"","title":"2)node_action_server_ros_iot_bridge.py"},{"location":"api_documentation/#3config_pyiotyaml","text":"","title":"3)config_pyiot.yaml"},{"location":"implementation/","text":"IMPLEMENTATION RQT Graph of the entire Implementation RQT Graph of entire implementation showing ungrouped action servers RQT Graph of entire implementation showing grouped action servers Enlarged RQT Graph section of node_action_server_ros_iot_bridge Once all the required nodes are launched, the node_action_server_ros_iot_bridge, which acts as a bridge between the iot servers and the local ros nodes recieves orders from the mqqt server topic /eyrc/vb/JAADjaad/orders, once orders reach the bridge, the same orders are published onto local topic /ros_iot_bridge/mqtt/sub, All the ros nodes requiring orders can subscribe to the local topic to receive it. This node also manages and behaves like an action server that can recieve goals from multiple action clients. Internal action topic such as /action_ros_iot are repsonsible for the same. The results obtained from the action clinets in form of goals are the published to multiple spreadsheets depending on the nature of the goal obtained. All communication to and from the internet happens through this node. Hence this acts as a bridge between the two. Enlarged RQT Graph section of node_t5 This is the first action client that contains classes responsible for sending goals to the action server , also this node performs image processing on the packages on the shelf, and initializes the ur5_1 arm and makes it ready for further tasks. Once all the classes are initialized the node is subscribing to topics /eyrc/vb/camera_1/image_raw to categorize the packages based on the color obtained from QR code decoding and the local mqtt sub topic ros_iot_bridge/mqtt/sub in order to recieve the orders. Before recieving the orders three different lists of colors are made, these lists will contain tuples of the packages segregated based on the color, this list will later be used to pick the packages after mapping it with the appropriate Item recieved from the orders, i.e Red->Medicine, Yellow->Food, Green->Clothes. The first name in the list of colors is sent as an argument to a function which will pick the appropriate package from the shelf and place it on the conveyor belt. This process keeps on repeating for all the orders on the subtopic ros_iot_bridge/mqtt/sub. Upon placing the packages on the conveyor the details of the order are encoded into a string and sent to the action server where it is decoded from string into readable format and this is goal which is sent calls the OrdersDispatched spredsheet updation functions in the action server which will proceed with the publishing , while the node_t5 is ready to perform the next pick and place task. This process continues for all the orders recieved on the sub topic. Enlarged RQT Graph section of node_t5_ur5_2 This is the second action client that talks with the action server , does image processing tasks and also initializes the ur5_2 arm. This node subscribes to the /eyrc_vb_logical_camera_2 node and uses these data to send the values encoded into a string to the action server which will manage the the spreadsheet updation for the inventory sheet, this is done for all the detected packages. As and when the packages are detected under logical_camera_2, node will check if the package is red, yellow or green and also when the package is exactly under the camera the ur5_2 arm is enabled to perform picking action. This is followed by dropping the packages in respective bins. As soon as the package is dropped into the bin, node/action client will send goal to server which will update the OrdersShipped spredsheet in Inventory Management Spredsheet.","title":"Implementation"},{"location":"implementation/#implementation","text":"","title":"IMPLEMENTATION"},{"location":"implementation/#rqt-graph-of-the-entire-implementation","text":"","title":"RQT Graph of the entire Implementation"},{"location":"implementation/#rqt-graph-of-entire-implementation-showing-ungrouped-action-servers","text":"","title":"RQT Graph of entire implementation showing ungrouped action servers"},{"location":"implementation/#rqt-graph-of-entire-implementation-showing-grouped-action-servers","text":"","title":"RQT Graph of entire implementation showing grouped action servers"},{"location":"implementation/#enlarged-rqt-graph-section-of-node_action_server_ros_iot_bridge","text":"Once all the required nodes are launched, the node_action_server_ros_iot_bridge, which acts as a bridge between the iot servers and the local ros nodes recieves orders from the mqqt server topic /eyrc/vb/JAADjaad/orders, once orders reach the bridge, the same orders are published onto local topic /ros_iot_bridge/mqtt/sub, All the ros nodes requiring orders can subscribe to the local topic to receive it. This node also manages and behaves like an action server that can recieve goals from multiple action clients. Internal action topic such as /action_ros_iot are repsonsible for the same. The results obtained from the action clinets in form of goals are the published to multiple spreadsheets depending on the nature of the goal obtained. All communication to and from the internet happens through this node. Hence this acts as a bridge between the two.","title":"Enlarged RQT Graph section of node_action_server_ros_iot_bridge"},{"location":"implementation/#enlarged-rqt-graph-section-of-node_t5","text":"This is the first action client that contains classes responsible for sending goals to the action server , also this node performs image processing on the packages on the shelf, and initializes the ur5_1 arm and makes it ready for further tasks. Once all the classes are initialized the node is subscribing to topics /eyrc/vb/camera_1/image_raw to categorize the packages based on the color obtained from QR code decoding and the local mqtt sub topic ros_iot_bridge/mqtt/sub in order to recieve the orders. Before recieving the orders three different lists of colors are made, these lists will contain tuples of the packages segregated based on the color, this list will later be used to pick the packages after mapping it with the appropriate Item recieved from the orders, i.e Red->Medicine, Yellow->Food, Green->Clothes. The first name in the list of colors is sent as an argument to a function which will pick the appropriate package from the shelf and place it on the conveyor belt. This process keeps on repeating for all the orders on the subtopic ros_iot_bridge/mqtt/sub. Upon placing the packages on the conveyor the details of the order are encoded into a string and sent to the action server where it is decoded from string into readable format and this is goal which is sent calls the OrdersDispatched spredsheet updation functions in the action server which will proceed with the publishing , while the node_t5 is ready to perform the next pick and place task. This process continues for all the orders recieved on the sub topic.","title":"Enlarged RQT Graph section of node_t5"},{"location":"implementation/#enlarged-rqt-graph-section-of-node_t5_ur5_2","text":"This is the second action client that talks with the action server , does image processing tasks and also initializes the ur5_2 arm. This node subscribes to the /eyrc_vb_logical_camera_2 node and uses these data to send the values encoded into a string to the action server which will manage the the spreadsheet updation for the inventory sheet, this is done for all the detected packages. As and when the packages are detected under logical_camera_2, node will check if the package is red, yellow or green and also when the package is exactly under the camera the ur5_2 arm is enabled to perform picking action. This is followed by dropping the packages in respective bins. As soon as the package is dropped into the bin, node/action client will send goal to server which will update the OrdersShipped spredsheet in Inventory Management Spredsheet.","title":"Enlarged RQT Graph section of node_t5_ur5_2"}]}